


<!--
==============================================================================

Copyright 2020-2023 by Jonathan Schmid-Burgk

==============================================================================
-->


<meta http-equiv="Content-Script-Type" content="text/javascript">
<META HTTP-EQUIV="CACHE-CONTROL" CONTENT="NO-CACHE">
    <html>
        <head>
            <title>ImageFiend 1.0</title>
        </head>
        <body>

            <br>Phenotype cell masks (1 channel, 2048x2048, 16bit):
            <br><input type="file" id="ImageFiles1" multiple/>
            
            <br>
            <br>Phenotype images (X channels, 2048x2048, 16bit):
            <br><input type="file" id="ImageFiles2" multiple/>


            <br>
            <br>List of cells to be included in collages:
            <br><input type="file" id="CellFile" /> Cell file (tab delimited, tile-ignored-x-y-sequence/gene) <button onclick="LoadCellFile();">load</button>

            <br>
            <br>Limit number of collages: <input id="limit_collages_num" value="1000" />
            <br>Tile size for each cell: <input id="collage_tile_size" value="70" /> px
            <br>Collage rows size (e.g. 5 means obtaining 5x5 grids): <input id="collage_rows" value="3" />
            <br>Collage color channel (counting from 1): <input id="collage_channel" value="2" /> out of <input id="collage_channels" value="3" /> channels
            <br>Enlarge masks by 2 pixels: <input type="checkbox" id="enlarge_mask" />
            <br>Scale down 2-fold: <input type="checkbox" id="scale_down" checked /> 
            <br>Overwrite tiles: <input type="checkbox" id="overwrite_tiles" checked /> 
            <br>
            <button onclick="StartCropping();">Auto Crop Cells</button>
            <button onclick="cropping_stop=1;">Stop</button>

            <br>
            <br>Minimum cells per collage: <input id="minimum_cells" value="3" />
            <br>Maximum cells per collage: <input id="maximum_cells" value="1000" />
            <br>Limit files to be saved: <input id="limit_save_collages_num" value="20" />
            <button onclick="SaveAllImages();">Save Collages</button>


            <br>
            <br>
            <br><input type="range" id="cycle" min="0" max="1" onchange="UpdateCanvas()" /> Type (insitu / phenotype)
            <br><input type="range" min="0" max="16000" id="tile" style="width:50%" onchange="UpdateCanvas()" /> Tile
            <br><input type="range" min="0" max="4" id="channel" onchange="UpdateCanvas()" /> Channel
            <br><input type="range" min="0" max="3" step="0.001" id="brightness" onchange="UpdateCanvas()" /> Brightness
            <br><input type="checkbox" id="showspots" onchange="UpdateCanvas()" /> Show Spots
            <br>

            


            <div style="position:absolute; top:0; right:0"><canvas id="maincanvas" width=2048 height=2048 style="width:800px; height:800px"></canvas></div>

            <div id="status" style="position:absolute; bottom:0; left:0"></div>

            <div id="save" style = "display:none">test</div>
        </body>
    </html>


    <script type="text/javascript" src="pako.js"></script>
    <script type="text/javascript" src="UTIF.js"></script>
    <script type="text/javascript" src="UPNG.js"></script>

    <script>


        var align_x, align_y, align_tile, align_q;

        var num_tiles1 = 0;

        function UpdateCanvas()
        {
          var cycle = document.getElementById("cycle").value*1;
          var tile = document.getElementById("tile").value*1;
          var channel = document.getElementById("channel").value*1;

          LoadImage(cycle, tile, channel, 0, 0);
        }

        var current_image_data;
        function LoadImage(cycle, tile, channel, filter, callback)
        {
          var brightness = document.getElementById("brightness").value*1;
          var showspots = document.getElementById("showspots").checked;

          var files = document.getElementById("ImageFiles1").files;
          var image_id;
          var file_id;
          var tile_p = tile;


          if (cycle==1) //phenotype
          {
              files = document.getElementById("ImageFiles2").files;
              file_id = tile*collage_channels + channel;
          }
          else //cell mask
          {
            file_id = tile*1;
          }


          var reader = new FileReader();
          reader.onload = function(evt)
          {
            //decode TIF:
            var ifds = UTIF.decode(reader.result);
            UTIF.decodeImage(reader.result, ifds[0]);
            var data = new Uint16Array(ifds[0].data);
            current_image_data = new Uint16Array(2048*2048);
            for (var i=0; i<2048*2048; i++) current_image_data[i] = data[i*2] + 256*data[i*2+1];

            //store data for later:
            cropping_image_data[current_cropping_cycle+current_cropping_channel] = current_image_data; //0-4

            var canvas = document.getElementById("maincanvas");
            //canvas.width = 1024;
            //canvas.height = 1024;
            var ImageContext = canvas.getContext("2d");
            var ImageData = ImageContext.getImageData(0, 0, 2048, 2048);
            var ImageArray = new Uint8Array(ImageData.data.buffer);


            var max = 0;
            for (var x=0; x<2048; x++) for (var y=0; y<2048; y++)
            {
              var xx = x;
              var yy = y;

              if (xx>=0 && xx<2048 && yy>=0 && yy<2048)
                if (current_image_data[x+y*2048] > max) max = current_image_data[xx+yy*2048];
            }

            for (var x=0; x<2048; x++) for (var y=0; y<2048; y++)
            {
                var index = x+2048*y;

                var val = 0;

                var xx = x;
                var yy = y;

                if (xx >= 0 && yy >= 0 && xx < 2048 && yy < 2048) val = current_image_data[xx+2048*yy]/max*255 *brightness;
                if (val > 255) val = 255;

                ImageArray[4*index+0] = val;
                ImageArray[4*index+1] = val;
                ImageArray[4*index+2] = val;
                ImageArray[4*index+3] = 255;
            }

    

            ImageContext.putImageData(ImageData, 0, 0);

            if (callback) callback();
          };
          reader.readAsArrayBuffer(files[file_id] /*.slice(start, start+2048*2048*2)*/ );
        }




        function display(data,w,h)
        {
          var canvas = document.getElementById("maincanvas");
          var ImageContext = canvas.getContext("2d");
          var ImageData = ImageContext.getImageData(0, 0, 2048, 2048);
          var ImageArray = new Uint8Array(ImageData.data.buffer);
          var max = 0;
          for (var x=0; x<w; x++) for (var y=0; y<h; y++) if (data[x+y*w]>max) max=data[x+y*w];
          for (var x=0; x<w; x++) for (var y=0; y<h; y++)
          {
              var index = x+2048*y;
              var val = data[x+y*w]/max*255;
              if (val>255) val=255;
              if (val<0) val=0;

              ImageArray[4*index+0] = val;
              ImageArray[4*index+1] = val;
              ImageArray[4*index+2] = val;
              ImageArray[4*index+3] = 255;
          }
          ImageContext.putImageData(ImageData, 0, 0);
          alert();
        }






        function SaveFile(data, filename)
        {
            var bb = new Blob([data], {type: 'text/plain'});
            var a = document.createElement('a');
            a.download = filename;
            a.href = window.URL.createObjectURL(bb);
            a.textContent = 'Klick here to save';
            a.dataset.downloadurl = ['text/plain', a.download, a.href].join(':');
            document.getElementById("save").appendChild(a);
            a.click();
        }

        function mouseDown(evt)
        {
            mouseDragging = true;

            var svg = document.getElementById("maincanvas");
            var box = svg.getBoundingClientRect();

            mouseX = evt.clientX-box.left;
            mouseY = evt.clientY-box.top;

            var mindist, best=-1;
            var tile_p = document.getElementById("tile").value*1;
            var tile_is = align_tile[document.getElementById("tile").value*1];
            for (var i=0; i<spot_num; i++) if (spot_tile[i] == tile_is)
            {
              var xx = Math.floor((mouseX/800*2048-1024)/3+align_x[tile_p]+1024);
              var yy = Math.floor((mouseY/800*2048-1024)/3+align_y[tile_p]+1024);

              var dx = spot_x[i] - xx;
              var dy = spot_y[i] - yy;
              var d = dx*dx + dy*dy;
              if (best==-1 || d<mindist)
              {
                best = i;
                mindist = d;
              }
            }
            //alert(mouseX+" "+mouseY)

            return false;
        }
        document.getElementById("maincanvas").addEventListener("mousedown", mouseDown, false);



        function keyPress(e)
        {
            if (e.key == '1') document.getElementById("channel").value = 0;
            if (e.key == '2') document.getElementById("channel").value = 1;
            if (e.key == '3') document.getElementById("channel").value = 2;
            if (e.key == '4') document.getElementById("channel").value = 3;
            if (e.key == '5') document.getElementById("channel").value = 4;
            if (e.key == 't') document.getElementById("tile").value--;
            if (e.key == 'z') document.getElementById("tile").value++;
            if (e.key == 'i') document.getElementById("cycle").value = 0;
            if (e.key == 'p') document.getElementById("cycle").value = 1;

            UpdateCanvas();
            //return false;
        }
        window.onkeypress = keyPress;



        var cells = 0;
        function LoadCellFile()
        {
          var reader = new FileReader();
          reader.onload = function(evt)
          {
            var table = reader.result.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");

            cell_tile = new Uint16Array(table.length-1);
            cell_cell = new Uint16Array(table.length-1);
            cell_x = new Int16Array(table.length-1);
            cell_y = new Int16Array(table.length-1);
            cell_seq = [];

            cells = 0;
            for (var i=1; i<table.length; i++)
            {
              var line = table[i].split("\t");
              if (line.length >= 4)
              {
                cell_tile[cells] = line[0]*1;
                cell_cell[cells] = line[1]*1;
                cell_x[cells] = line[2]*1;
                cell_y[cells] = line[3]*1;
                if (line.length > 4) cell_seq[cells] = line[4];
                else cell_seq[cells] = "all";

                cells++;
              }
            }
          };
          reader.readAsText(document.getElementById("CellFile").files[0]);
        }

        var current_cropping_cycle = 0, current_cropping_tile = 0, current_cropping_channel = 0;
        var cropping_image_data = [];
        var cropping_stop;
        var collage_rows = 3;
        var collage_tile_size = 300;
        var collage_channel = 2, collage_channels = 3;
        var enlarge_mask = false;
        var minimum_cells = 3;
        var scale_down = false;
        var overwrite_tiles = false;
        function StartCropping()
        {
          num_tiles1=document.getElementById("ImageFiles1").files.length/1;
          collage_rows = document.getElementById("collage_rows").value*1;
          collage_tile_size = document.getElementById("collage_tile_size").value*1;
          collage_channel = document.getElementById("collage_channel").value*1 -1; //counting from 0
          collage_channels = document.getElementById("collage_channels").value*1;
          enlarge_mask = document.getElementById("enlarge_mask").checked;
          scale_down = document.getElementById("scale_down").checked;
          overwrite_tiles = document.getElementById("overwrite_tiles").checked;

          out = "";
          current_cropping_cycle = 0;
          current_cropping_tile = 0;
          current_cropping_channel = 0;
          cropping_stop = 0;
          LoadImage(current_cropping_cycle, current_cropping_tile, current_cropping_channel, 0, CroppingCallback);
        }
        function CroppingCallback()
        {
          if (cropping_stop) return;
          document.getElementById("status").innerHTML = current_cropping_cycle+" "+current_cropping_tile+" "+current_cropping_channel;

          if (current_cropping_cycle == 0) //mask
          {
            current_cropping_cycle = 1;
            current_cropping_channel = 0;
            LoadImage(current_cropping_cycle, current_cropping_tile, current_cropping_channel, 0, CroppingCallback);
          }
          else //confocal
          {
            if (current_cropping_channel < collage_channels-1)
            {
              current_cropping_channel++;
              LoadImage(current_cropping_cycle, current_cropping_tile, current_cropping_channel, 0, CroppingCallback);
            }
            else //all data here
            {
              CropCells(current_cropping_tile);

              //current_cropping_tile++;

              //speed up by jumping if no cell:
              var next=1;
              while (next && current_cropping_tile < num_tiles1)
              {
                current_cropping_tile++;
                for (var c=0; c<cell_tile.length; c++) if (cell_tile[c] == current_cropping_tile)
                {
                  next = 0;
                  break;
                }
              }

              current_cropping_cycle = 0;
              current_cropping_channel = 0;

              if (current_cropping_tile < num_tiles1) LoadImage(current_cropping_cycle, current_cropping_tile, current_cropping_channel, 0, CroppingCallback);
              else
              {
                //SaveCroppingFile();
                alert("done");               
              }
            }
          }
        }
        var collages = [], collages_counter = [], collages_num = 0;
        function CropCells(tile)
        {
          var limit_collages_num = document.getElementById("limit_collages_num").value*1;
          var scale = 1;
          if (scale_down) scale = 2;

          for (var c=0; c<cells; c++) if (cell_tile[c] == tile)
          {
            var cx = cell_x[c];
            var cy = cell_y[c];
            var mask = cropping_image_data[0][cx+2048*cy]; //cell_cell[c];
            var seq = cell_seq[c];

            if (mask != 0)
            {
              if (collages[seq] === undefined && collages_num < limit_collages_num)
              {
                collages[seq] = new Uint16Array(collage_rows*collage_rows * collage_tile_size*collage_tile_size /* *3 */);
                collages_counter[seq] = 0;
                collages_num++;
              }

              if (collages[seq] !== undefined)
              {
                var tileposition = collages_counter[seq];
                if (overwrite_tiles) tileposition = tileposition%(collage_rows*collage_rows);

                var collagex = tileposition%collage_rows;
                var collagey = Math.floor(tileposition/collage_rows);

                if (tileposition<collage_rows*collage_rows)
                {
                  for (var x=0; x<collage_tile_size*scale; x++) for (var y=0; y<collage_tile_size*scale; y++)
                  {
                    var xx = cx-Math.floor(collage_tile_size/2*scale)+x;
                    var yy = cy-Math.floor(collage_tile_size/2*scale)+y;

                    var win = 0;
                    if (cropping_image_data[0][xx+2048*yy] == mask) win = 1;

                    if (enlarge_mask)
                    {
                      var enlarge = 2;
                      for (var mx=xx-enlarge; mx<=xx+enlarge; mx+=2)
                        for (var my=yy-enlarge; my<=yy+enlarge; my+=2)
                          if (mx>=0 && mx<2048 && my>=0 && my<2048)
                            if (cropping_image_data[0][mx+2048*my] == mask) win = 1;
                    }

                    //add to collage:
                    if (xx>=0 && xx<2048 && yy>=0 && yy<2048)
                    {
                      var xxx = collage_tile_size*collagex + Math.floor(x/scale);
                      var yyy = collage_tile_size*collagey + Math.floor(y/scale);
                      
                      //collages[seq][xxx + collage_tile_size*collage_rows*yyy] += win*cropping_image_data[1+collage_channel][xx+2048*yy] /(scale*scale); //without /4 some images saturate

                      //overwrite, loose information but allow uprating last cells:
                      collages[seq][xxx + collage_tile_size*collage_rows*yyy] = win*cropping_image_data[1+collage_channel][xx+2048*yy];
                    }
                  }
                  //hide info:
                  //collages[seq][0*collage_rows*collage_rows*collage_tile_size*collage_tile_size + collage_tile_size*collagex + collage_tile_size*collage_rows*collage_tile_size*collagey] = c;
                }
                collages_counter[seq]++;
              }
            }
          }
        }

        function SaveImage(name, ch)
        {
          var filename = name+"_"+collages_counter[name]+".png";

          var input_image8 = new Uint8Array(collages[name].buffer);
          var inverted = new Uint8Array(collage_tile_size*collage_rows*collage_tile_size*collage_rows*2);
          for (var x=0; x<collage_tile_size*collage_rows; x++)
            for (var y=0; y<collage_tile_size*collage_rows; y++)
            {
              inverted[x*2 + y*collage_tile_size*collage_rows*2   ] = input_image8[ch*collage_rows*collage_rows*collage_tile_size*collage_tile_size*2 + x*2 + y*collage_tile_size*collage_rows*2 +1];
              inverted[x*2 + y*collage_tile_size*collage_rows*2 +1] = input_image8[ch*collage_rows*collage_rows*collage_tile_size*collage_tile_size*2 + x*2 + y*collage_tile_size*collage_rows*2   ];
            }

          var dummy = [];
          dummy[0] = inverted.buffer;

          //save as PNG (load multipage PNG in imageJ with bioformat importer):
          var newimage = UPNG.encodeLL(dummy, collage_tile_size*collage_rows, collage_tile_size*collage_rows, 1, 0, 16, 1000); //data, w, h, colors, alphas, bits, milliseconds per frame
          var bb = new Blob([newimage], {type: 'application/octet-stream'});
          var a = document.createElement('a');
          a.download = filename;
          a.href = window.URL.createObjectURL(bb);
          a.textContent = 'Klick here to save';
          a.dataset.downloadurl = ['text/plain', a.download, a.href].join(':');
          document.getElementById("save").appendChild(a);
          a.click();
        }
        function SaveAllImages()
        {
          var limit_save_collages_num = document.getElementById("limit_save_collages_num").value*1; //can be changed
          minimum_cells = document.getElementById("minimum_cells").value*1;
          maximum_cells = document.getElementById("maximum_cells").value*1;

          var save_counter = 0;
          for (var name in collages) if (collages_counter[name] >= minimum_cells && collages_counter[name] <= maximum_cells && save_counter < limit_save_collages_num)
          {
            SaveImage(name, 0);
            save_counter++;
          }
        }


    </script>
