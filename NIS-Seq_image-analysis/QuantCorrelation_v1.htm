


<!--
==============================================================================

Copyright 2020-2023 by Jonathan Schmid-Burgk

==============================================================================
-->


<meta http-equiv="Content-Script-Type" content="text/javascript">
<META HTTP-EQUIV="CACHE-CONTROL" CONTENT="NO-CACHE">
    <html>
        <head>
            <title>ImageFiend 1.0</title>
        </head>
        <body>

            <br>Phenotype cell masks (1 channel, 2048x2048, 16bit):
            <br><input type="file" id="ImageFiles1" onchange="num_tiles1=this.files.length/1;" multiple/>
            
            <br>
            <br>Phenotype images (3 channels, 2048x2048, 16bit):
            <br><input type="file" id="ImageFiles2" onchange="num_tiles2=this.files.length/3;" multiple/>




            <br>
            <br>
            <br><input type="range" id="cycle" min="0" max="1" onchange="UpdateCanvas()" /> Type (insitu / phenotype)
            <br><input type="range" min="0" max="16000" id="tile" style="width:50%" onchange="UpdateCanvas()" /> Tile
            <br><input type="range" min="0" max="4" id="channel" onchange="UpdateCanvas()" /> Channel
            <br><input type="range" min="0" max="300" step="0.001" id="brightness" onchange="UpdateCanvas()" /> Brightness
            <br>

            <br>
            <button onclick="StartCropping();">Start Analysis</button>
            <button onclick="cropping_stop=1;">Stop</button>
            


            <div style="position:absolute; top:0; right:0"><canvas id="maincanvas" width=2048 height=2048 style="width:800px; height:800px"></canvas></div>

            <div id="status" style="position:absolute; bottom:0; left:0"></div>

            <div id="save" style = "display:none">test</div>
        </body>
    </html>


    <script type="text/javascript" src="pako.js"></script>
    <script type="text/javascript" src="UTIF.js"></script>
    <script type="text/javascript" src="UPNG.js"></script>

    <script>


        var align_x, align_y, align_tile, align_q;

        var num_tiles1 = 0;
        var num_tiles2 = 0;

        function UpdateCanvas()
        {
          var cycle = document.getElementById("cycle").value*1;
          var tile = document.getElementById("tile").value*1;
          var channel = document.getElementById("channel").value*1;

          LoadImage(cycle, tile, channel, 0, 0);
        }

        var current_image_data;
        function LoadImage(cycle, tile, channel, filter, callback)
        {
          var brightness = document.getElementById("brightness").value*1;

          var files = document.getElementById("ImageFiles1").files;
          var image_id;
          var file_id;
          var tile_p = tile;


          if (cycle==1) //phenotype
          {
              files = document.getElementById("ImageFiles2").files;
              file_id = tile*3 + channel;
          }
          else //cell mask
          {
            file_id = tile*1;
          }


          var reader = new FileReader();
          reader.onload = function(evt)
          {
            //decode TIF:
            var ifds = UTIF.decode(reader.result);
            UTIF.decodeImage(reader.result, ifds[0]);
            var data = new Uint16Array(ifds[0].data);
            current_image_data = new Uint16Array(2048*2048);
            for (var i=0; i<2048*2048; i++) current_image_data[i] = data[i*2] + 256*data[i*2+1];

            var canvas = document.getElementById("maincanvas");
            //canvas.width = 1024;
            //canvas.height = 1024;
            var ImageContext = canvas.getContext("2d");
            var ImageData = ImageContext.getImageData(0, 0, 2048, 2048);
            var ImageArray = new Uint8Array(ImageData.data.buffer);

            /*var background_subtraction = document.getElementById("background_subtraction").checked;
            if (background_subtraction && cycle==1)
            {
              //downsample 8x:
              var downsampled = new Float32Array(256*256);
              for (var x=0; x<2048; x++) for (var y=0; y<2048; y++)
              {
                var xx = Math.floor(x/8);
                var yy = Math.floor(y/8);
                downsampled[xx+256*yy] += current_image_data[x+y*2048] / 64;
              }
              //find lowest px in 9x9 grid:
              for (var x=0; x<2048; x++) for (var y=0; y<2048; y++)
              {
                var xx = Math.floor(x/8);
                var yy = Math.floor(y/8);
                var minval = 1000000;
                for (var dx=-4; dx<=4; dx++)
                  if (xx+dx >= 0 && xx+dx < 256)
                    for (var dy=-4; dy<=4; dy++)
                      if (yy+dy >= 0 && yy+dy < 256)
                {
                  var val = downsampled[xx+dx+256*(yy+dy)];
                  if (val < minval) minval = val;
                }
                //subtract:
                if (current_image_data[x+y*2048]>minval) current_image_data[x+y*2048] -= minval;
                else current_image_data[x+y*2048] = 0;
              }
            }*/

            /*var highpass = document.getElementById("highpass").checked;
            if (highpass && cycle==1)
            {
              var sum_gfp_highpass = new Float32Array(2048*2048);
              var LP1 = new Float32Array(2048*2048), LP2 = new Float32Array(2048*2048);
              for (var x=0; x<2048; x++) for (var y=0; y<2048; y++) LP1[x+y*2048] = current_image_data[x+y*2048];
              for (var round=0; round<3; round++)
              {
                for (var x=0; x<2048-1; x++) for (var y=0; y<2048; y++) LP1[x+y*2048] = (LP1[x+y*2048]+LP1[x+1+y*2048])/2;
                for (var x=2048-1; x>0; x--) for (var y=0; y<2048; y++) LP1[x+y*2048] = (LP1[x+y*2048]+LP1[x-1+y*2048])/2;
                for (var y=0; y<2048-1; y++) for (var x=0; x<2048; x++) LP1[x+y*2048] = (LP1[x+y*2048]+LP1[x+(y+1)*2048])/2;
                for (var y=2048-1; y>0; y--) for (var x=0; x<2048; x++) LP1[x+y*2048] = (LP1[x+y*2048]+LP1[x+(y-1)*2048])/2;

                if (round == 0) for (var x=0; x<2048; x++) for (var y=0; y<2048; y++) LP2[x+y*2048] = LP1[x+y*2048];
              }
              for (var x=0; x<2048; x++) for (var y=0; y<2048; y++)
              {
                if (LP2[x+y*2048] > LP1[x+y*2048]) sum_gfp_highpass[x+y*2048] = LP2[x+y*2048] - LP1[x+y*2048];
                else sum_gfp_highpass[x+y*2048] = 0;
              }
              for (var x=0; x<2048; x++) for (var y=0; y<2048; y++) current_image_data[x+y*2048] = sum_gfp_highpass[x+y*2048]; //LP1[x+y*2048]
            }*/


            var max = 0;
            for (var x=0; x<2048; x++) for (var y=0; y<2048; y++)
            {
              var xx = x;
              var yy = y;

              if (xx>=0 && xx<2048 && yy>=0 && yy<2048)
                if (current_image_data[x+y*2048] > max) max = current_image_data[xx+yy*2048];
            }

            for (var x=0; x<2048; x++) for (var y=0; y<2048; y++)
            {
                var index = x+2048*y;

                var val = 0;

                var xx = x;
                var yy = y;

                if (xx >= 0 && yy >= 0 && xx < 2048 && yy < 2048) val = current_image_data[xx+2048*yy]/max*255 *brightness;
                if (val > 255) val = 255;

                ImageArray[4*index+0] = val;
                ImageArray[4*index+1] = val;
                ImageArray[4*index+2] = val;
                ImageArray[4*index+3] = 255;

                if (cell_highlighted[mask_image[x+2048*y]]) ImageArray[4*index+0] = 255;
            }

    

            ImageContext.putImageData(ImageData, 0, 0);

            if (callback) callback();
          };
          reader.readAsArrayBuffer(files[file_id] /*.slice(start, start+2048*2048*2)*/ );
        }






        function SaveFile(data, filename)
        {
            var bb = new Blob([data], {type: 'text/plain'});
            var a = document.createElement('a');
            a.download = filename;
            a.href = window.URL.createObjectURL(bb);
            a.textContent = 'Klick here to save';
            a.dataset.downloadurl = ['text/plain', a.download, a.href].join(':');
            document.getElementById("save").appendChild(a);
            a.click();
        }


        var current_cropping_cycle = 0, current_cropping_tile = 0, current_cropping_channel = 0;
        var cropping_image_data = [];
        var cropping_stop;
        function StartCropping()
        {
          out = "tile\tcell\tx\ty\tcell_area\tnuc\tgfp\tnuc_norm\tgfp_norm\tcorrelation\n";
          current_cropping_cycle = 0;
          current_cropping_tile = 0;
          current_cropping_channel = 0;
          cropping_stop = 0;
          LoadImage(current_cropping_cycle, current_cropping_tile, current_cropping_channel, 0, CroppingCallback);
        }
        var nuc_image = new Float32Array(2048*2048), gfp_image = new Float32Array(2048*2048), mask_image = new Float32Array(2048*2048);
        function CroppingCallback()
        {
          if (cropping_stop) return;
          document.getElementById("status").innerHTML = current_cropping_cycle+" "+current_cropping_tile+" "+current_cropping_channel;

          if (current_cropping_cycle == 0) //mask
          {
            for (var i=0; i<2048*2048; i++) mask_image[i] = current_image_data[i];

            current_cropping_cycle = 1; //type = images
            current_cropping_channel = 0; //nuc
            LoadImage(current_cropping_cycle, current_cropping_tile, current_cropping_channel, 0, CroppingCallback);
          }
          else if (current_cropping_channel == 0) //confocal nuc
          {
            for (var i=0; i<2048*2048; i++) nuc_image[i] = current_image_data[i];

            current_cropping_channel = 1; //gfp
            LoadImage(current_cropping_cycle, current_cropping_tile, current_cropping_channel, 0, CroppingCallback);
          }
          else //confocal gfp
          {
            for (var i=0; i<2048*2048; i++) gfp_image[i] = current_image_data[i];
            
            QuantifyPhenotypes();

            current_cropping_cycle = 0; //mask
            current_cropping_channel = 0;
            current_cropping_tile++;

            /*if (current_cropping_tile < num_tiles2)*/
            if (current_cropping_tile < document.getElementById("ImageFiles1").files.length) LoadImage(current_cropping_cycle, current_cropping_tile, current_cropping_channel, 0, CroppingCallback);
            else
            {
              SaveFile(out, "Phenotypes.txt");
              alert("done");               
            }
          }
        }

        var out;
        function QuantifyPhenotypes()
        {
          //mask: mask_image
          //data: nuc_image, gfp_image

          cell_area = new Float32Array(10000);
          cell_x = new Float32Array(10000);
          cell_y = new Float32Array(10000);
          cell_nuc_sum = new Float32Array(10000);
          cell_gfp_sum = new Float32Array(10000);
          cell_nuc2_sum = new Float32Array(10000);
          cell_gfp2_sum = new Float32Array(10000);
          cell_nuc_gfp_sum = new Float32Array(10000);
          var cellnum = 0;

          //aggregate signal per cell:
          for (var x=0; x<2048; x++) for (var y=0; y<2048; y++) 
          {
            var cell = mask_image[x+y*2048];
            if (cell > 0)
            {
              cell_area[cell]++;
              cell_x[cell] += x;
              cell_y[cell] += y;
              cell_nuc_sum[cell] += nuc_image[x+y*2048];
              cell_gfp_sum[cell] += gfp_image[x+y*2048];
              cell_nuc2_sum[cell] += nuc_image[x+y*2048]**2;
              cell_gfp2_sum[cell] += gfp_image[x+y*2048]**2;
              cell_nuc_gfp_sum[cell] += nuc_image[x+y*2048] * gfp_image[x+y*2048];

              if (cell > cellnum) cellnum = cell;
            }
          }

          //output list:
          for (var cell=1; cell<cellnum; cell++)
          {
            var n = cell_area[cell];
            var xsum = cell_nuc_sum[cell];
            var ysum = cell_gfp_sum[cell];
            var xxsum = cell_nuc2_sum[cell];
            var yysum = cell_gfp2_sum[cell];
            var xysum = cell_nuc_gfp_sum[cell];
            var r = (n*xysum-xsum*ysum)/(Math.sqrt(n*xxsum-xsum*xsum)*Math.sqrt(n*yysum-ysum*ysum));

            out += current_cropping_tile+"\t"+cell+"\t"+
                   Math.floor(cell_x[cell]/cell_area[cell])+"\t"+Math.floor(cell_y[cell]/cell_area[cell])+"\t"+
                   cell_area[cell]+"\t"+
                   cell_nuc_sum[cell]+"\t"+cell_gfp_sum[cell]+"\t"+cell_nuc_sum[cell]/cell_area[cell]+"\t"+cell_gfp_sum[cell]/cell_area[cell]+"\t"+
                   r+"\n";
          } 
        }

        var cell_highlighted = new Uint8Array(1000000);
        function mouseDown(evt)
        {
            mouseDragging = true;

            var svg = document.getElementById("maincanvas");
            var box = svg.getBoundingClientRect();

            mouseX = Math.floor((evt.clientX-box.left)/800*2048);
            mouseY = Math.floor((evt.clientY-box.top)/800*2048);

            var clickedcell = mask_image[mouseX+mouseY*2048];
            for (var i=0; i<1000000; i++) cell_highlighted[i] = 0;
            cell_highlighted[clickedcell] = 1;

            if (clickedcell != 0)
            {
              document.getElementById("status").innerHTML = "cell: "+clickedcell+" gfp: "+Math.round(cell_gfp_sum[clickedcell]/cell_area[clickedcell])+" speck: "+Math.round(cell_gfp_spot_sum[clickedcell]/cell_area[clickedcell]*100)+" ratio: "+Math.round(cell_gfp_spot_sum[clickedcell]/cell_gfp_sum[clickedcell]*100*1000)/1000;
            }

            UpdateCanvas();

            return false;
        }
        document.getElementById("maincanvas").addEventListener("mousedown", mouseDown, false);
   


    </script>
