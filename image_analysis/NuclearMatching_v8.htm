


<!--
==============================================================================

Copyright 2020-2024 by Jonathan Schmid-Burgk

==============================================================================
-->


<meta http-equiv="Content-Script-Type" content="text/javascript">
<META HTTP-EQUIV="CACHE-CONTROL" CONTENT="NO-CACHE">
    <html>
        <head>
            <title>ImageFiend 1.0</title>
        </head>
        <body style="margin: 0; font-family: Helvetica; font-weight: 100; background-size: 200vw 200vh" background="brown1.jpg">
          <div style="background-color: rgba(255,255,255,0.2); margin: 0.5%; padding: 1%; width: 47.25%; height: 100%">
            <b>NIS-Seq Analysis Suite v1.0 - Nuclei Matching</b>
            <br>JSB lab 2020-2024
            <br>

            <br>Phenotyping nuclear masks (TIFF, 1 channel, 2048x2048, 16 bit, sorted by tile):
            <br><input type="file" id="ImageFiles1" multiple/>
            <br>
            <br>Phenotyping membrane masks (TIFF, 1 channel, 2048x2048, 16 bit, sorted by tile):
            <br><input type="file" id="ImageFiles3" multiple/>
            <br>
            <br>In-situ nuclear masks (TIFF, 1 channel, 2048x2048, 16 bit, sorted by tile):
            <br><input type="file" id="ImageFiles2" multiple/>
            <br>
            <br>Nuclear alignment file (tab delimited, pheno tile - insitu tile - x - y)
            <br><input type="file" id="AlignmentFile" onchange="LoadAlignmentFile();" />
            <br>
            <br>Scaling factor (in-situ pixel size / phenotype pixel size): <input id="scaling" value="3"/>
            <br>Maximum cell movement (in-situ pixels): <input id="maxdist" value="33"/>
            <br>Area gating (only pair nuclei with similar size): <input type="checkbox" id="area_gating" checked/>
            <br>

            <br>Optional: Use overlapping tiles to match nuclei:
            <input type="checkbox" id="use_overlapping_tiles"/>
            <br><input type="file" id="StageFile1" onchange="LoadStageFile1();" /> Stage positions (time - well - tile - x µm - y µm, with header)
            <br>pixel offset per in-situ tile (x): <input id="px_per_step" value="1905"/>
            <br>pixel offset per in-situ tile (y): <input id="py_per_step" value="-45"/>

            <br>
            <br><button onclick="StartCropping();">Detect, assign, save cells </button>

          </div>

          <div style="position:absolute; top:0; right:0; background-color: rgba(255,255,255,0.2); margin: 0.5%; padding: 1%; width: 47.25%; height: 100%">
            <b>Inspect raw images:</b>
            <br><br>
            <canvas id="maincanvas" width=2048 height=2048 style="width: 40vw; height: 40vw"></canvas>
            <br>
            <br><input type="range" id="cycle" min="0" max="2" value="0" onchange="UpdateCanvas()" /> Type (insitu / phenotype)
            <br><input type="range" min="0" max="2000" value="0" id="tile" onchange="UpdateCanvas()" /> Tile
            <br><input type="range" min="0" max="3" value="0" id="channel" onchange="UpdateCanvas()" /> Channel
            <br><input type="range" min="0" max="4" step="0.001" id="brightness" onchange="UpdateCanvas()" /> Brightness
            <br><input type="checkbox" id="showspots" onchange="UpdateCanvas()" /> Show spots
            <br><input type="checkbox" id="showscaled" onchange="UpdateCanvas()" /> Show scaled
          </div>



          <div id="status" style="position:absolute; bottom:0; left:0"></div>
          <div id="save" style = "display:none">test</div>
        </body>
    </html>

    <script type="text/javascript" src="pako.js"></script>
    <script type="text/javascript" src="UTIF.js"></script>
    <script>


        /// GENERAL PUROPSE FUNCTIONS ///

        function UpdateCanvas() //this callback function reads the GUI and updates the presented raw image
        {
          var cycle = document.getElementById("cycle").value*1;
          var tile = document.getElementById("tile").value*1;
          var channel = document.getElementById("channel").value*1;

          LoadImage(cycle, tile, channel, 0, 0);
        }

        var current_image_data;
        function LoadImage(cycle, tile, channel, filter, callback) //this function loads a specific raw image
        {
          var brightness = document.getElementById("brightness").value*1;
          var scaling = document.getElementById("scaling").value*1;
          var showspots = document.getElementById("showspots").checked;
          var showscaled = document.getElementById("showscaled").checked;

          var files;
          var image_id = tile*1;

          if (cycle==0) //pheno
          {
            files = document.getElementById("ImageFiles1").files;
          }
          if (cycle==1) //insitu
          {
            files = document.getElementById("ImageFiles2").files;
            if (showscaled) image_id = align_tile[tile*1];
          }
          if (cycle==2) //pheno mem
          {
            files = document.getElementById("ImageFiles3").files;
          }

          var reader = new FileReader();
          reader.onload = function(evt)
          {
            //decode TIFF:
            var ifds = UTIF.decode(reader.result);
            UTIF.decodeImage(reader.result, ifds[0]);
            var data = new Uint16Array(ifds[0].data);
            current_image_data = new Uint16Array(2048*2048);
            for (var i=0; i<2048*2048; i++) current_image_data[i] = data[i*2] + 256*data[i*2+1];

            //get access to main canvas object:
            var canvas = document.getElementById("maincanvas");
            var ImageContext = canvas.getContext("2d");
            var ImageData = ImageContext.getImageData(0, 0, 2048, 2048);
            var ImageArray = new Uint8Array(ImageData.data.buffer);

            //determine the max pixel intensity:
            var max = 0;
            for (var x=0; x<2048; x++) for (var y=0; y<2048; y++)
            {
              	var xx = x;
              	var yy = y;

              	if (showscaled && cycle==0)
  	            {
  	            	  xx = Math.floor((x-1024-align_x[tile])*scaling+1024);
  	        		    yy = Math.floor((y-1024-align_y[tile])*scaling+1024);
  	            }

              	if (xx>=0 && xx<2048 && yy>=0 && yy<2048) if (current_image_data[x+y*2048] > max) max = current_image_data[xx+yy*2048];
            }

            //scale image brightness to 0-255:
            for (var x=0; x<2048; x++) for (var y=0; y<2048; y++)
            {
                var index = x+2048*y;

                var val = 0;

                var xx = x;
                var yy = y;

                if (showscaled && cycle==0)
                {
                	xx = Math.floor((x-1024-align_x[tile])*scaling+1024);
            		  yy = Math.floor((y-1024-align_y[tile])*scaling+1024);
                }

                if (xx >= 0 && yy >= 0 && xx < 2048 && yy < 2048) val = current_image_data[xx+2048*yy]/max*255 *brightness;
                if (val > 255) val = 255;

                ImageArray[4*index+0] = val;
                ImageArray[4*index+1] = val;
                ImageArray[4*index+2] = val;
                ImageArray[4*index+3] = 255;
            }

            //show spots on phenotype images as random-colored squares:
            if (showspots && cycle==0) //pheno
            {
              for (var i=0; i<p_cell_num; i++) if (p_cell_tile[i] == tile)
              {
                //pick a random color:
              	var map = p_cell_map[i];
                var r = (340850327*map)%255;
                var g = (934895*map)%255;
                var b = (3538497218*map)%255;

                if (map != -1)
                	for (var xxx=-5; xxx<=5; xxx++) //if (xxx<=-3 || xxx>=3) //5x5 px black
                  		for (var yyy=-5; yyy<=5; yyy++)
                {
                  var xx = Math.floor(p_cell_x[i]+xxx);
                  var yy = Math.floor(p_cell_y[i]+yyy);
                  if (showscaled)
                  {
                    var xx = Math.floor((p_cell_x[i]-1024)/scaling+1024+align_x[tile]+xxx);
                    var yy = Math.floor((p_cell_y[i]-1024)/scaling+1024+align_y[tile]+yyy);
                  }

                  if (xx>=0 && xx < 2048 && yy>=0 && yy <2048)
                  {
                    var index = xx+2048*yy;
                    ImageArray[4*index+0] = r;
                    ImageArray[4*index+1] = g;
                    ImageArray[4*index+2] = b;
                    ImageArray[4*index+3] = 255;
                  }
                }
              }
            }

            //show spots on NIS images as random-colored squares:
            if (showspots && cycle==1) //insitu
            {
              for (var i=0; i<i_cell_num; i++) if (i_cell_tile[i] == tile)
              {
                //pick a random color:
                var r = (340850327*i)%255;
                var g = (934895*i)%255;
                var b = (3538497218*i)%255;

                for (var xxx=-5; xxx<=5; xxx++) //if (xxx<=-3 || xxx>=3) //5x5 px black
                  for (var yyy=-5; yyy<=5; yyy++)
                {
                  var xx = Math.floor(i_cell_x[i]+xxx);
                  var yy = Math.floor(i_cell_y[i]+yyy);

                  if (xx>=0 && xx < 2048 && yy>=0 && yy <2048)
                  {
                    var index = xx+2048*yy;
                    ImageArray[4*index+0] = r;
                    ImageArray[4*index+1] = g;
                    ImageArray[4*index+2] = b;
                    ImageArray[4*index+3] = 255;
                  }
                }
              }
            }

            //show scaled image:
            ImageContext.putImageData(ImageData, 0, 0);

            if (callback) callback();
          };
          reader.readAsArrayBuffer(files[image_id]);
        }

        var StagePositions1X = [], StagePositions1Y = [];
        function LoadStageFile1() //this function loads the stage positions from a file
        {
          var reader = new FileReader();
          reader.onload = function(evt)
          {
            var table = reader.result.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
            
            for (var i=0; i<table.length-1; i++)
            {
              var line = table[i+1].split("\t");

              StagePositions1X[i] = line[3+0]*1;
              StagePositions1Y[i] = line[3+1]*1;
            }

            //normalize to stage steps (assuming a simple grid, starting left-to-right):
            var StagePositionStep = StagePositions1X[1]-StagePositions1X[0];
            var StagePositionX0 = StagePositions1X[0];
            var StagePositionY0 = StagePositions1Y[0];
            for (var i=0; i<table.length-1; i++)
            {
              StagePositions1X[i] = Math.round((StagePositions1X[i]-StagePositionX0)/StagePositionStep);
              StagePositions1Y[i] = Math.round((StagePositions1Y[i]-StagePositionY0)/StagePositionStep);
            }
          };
          reader.readAsText(document.getElementById("StageFile1").files[0]);
        }

        var align_x, align_y, align_tile, align_q;
        function LoadAlignmentFile() //this function loads the pixel offsets between phenotype and NIS images for each tile
        {
          var reader = new FileReader();
          reader.onload = function(evt)
          {
            var table = reader.result.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
            var estimated_tile_num = table.length*2;

            align_tile = new Int16Array(estimated_tile_num);
            for (var i=0; i<estimated_tile_num; i++) align_tile[i] = -1;
            align_x = new Int16Array(estimated_tile_num);
            align_y = new Int16Array(estimated_tile_num);
            align_q = new Int16Array(estimated_tile_num);

            for (var i=0; i<table.length; i++)
            {
              var line = table[i].split("\t");

              var ii = line[0]*1;
              if (ii >= 0 && ii < estimated_tile_num)
              {
                align_tile[ii] = line[1]*1;
                align_x[ii] = line[2]*1;
                align_y[ii] = line[3]*1;
                align_q[ii] = line[4]*1;
              }
            }
          };
          reader.readAsText(document.getElementById("AlignmentFile").files[0]);
        }

        function SaveFile(data, filename) //this function saves the content of data to a file
        {
            var bb = new Blob([data], {type: 'text/plain'});
            var a = document.createElement('a');
            a.download = filename;
            a.href = window.URL.createObjectURL(bb);
            a.textContent = 'Klick here to save';
            a.dataset.downloadurl = ['text/plain', a.download, a.href].join(':');
            document.getElementById("save").appendChild(a);
            a.click();
        }






        /// NUCLEI MATCHING ///

        var current_cropping_cycle = 0, current_cropping_tile = 0;
        var total_aligned_cells, total_assigned_cells;
        function StartCropping() //this function initiates a callback loop to assign nuclei in all masks
        {
          out = "";
          current_cropping_cycle = 0;
          current_cropping_tile = 0;
          total_aligned_cells = 0;
          total_assigned_cells = 0;
          LoadImage(current_cropping_cycle, current_cropping_tile, 0, 0, CroppingCallback);
        }

        function CroppingCallback() //this callback function loads the next mask, starts registering nuclei, or saves the final results
        {
          document.getElementById("status").innerHTML = " tile-"+current_cropping_tile;

          if (current_cropping_cycle == 0) // pheno
          {
            DetectCells();

            //copy to global array:
            if (align_tile[current_cropping_tile] != -1) //exclude tiles with no aligned in-situ tile
              for (var i=0; i<cell_num; i++)
                  if (cell_x[i]>edge && cell_x[i]<2048-edge && cell_y[i]>edge && cell_y[i]<2048-edge)
            {
              p_cell_tile[p_cell_num] = current_cropping_tile;
              p_cell_x[p_cell_num] = cell_x[i];
              p_cell_y[p_cell_num] = cell_y[i];
              p_cell_n[p_cell_num] = cell_n[i];
              p_cell_num++;
            }

            current_cropping_tile++;
            if (current_cropping_tile < document.getElementById("ImageFiles1").files.length) LoadImage(current_cropping_cycle, current_cropping_tile, 0, 0, CroppingCallback);
            else
            {
              current_cropping_cycle = 1;
              current_cropping_tile = 0;
              LoadImage(current_cropping_cycle, current_cropping_tile, 0, 0, CroppingCallback);
            }
            return;
          }
          if (current_cropping_cycle == 1) // insitu
          {
            DetectCells();

            //copy to global array:
            for (var i=0; i<cell_num; i++)
                if (cell_x[i]>edge && cell_x[i]<2048-edge && cell_y[i]>edge && cell_y[i]<2048-edge)
            {
              i_cell_tile[i_cell_num] = current_cropping_tile;
              i_cell_x[i_cell_num] = cell_x[i];
              i_cell_y[i_cell_num] = cell_y[i];
              i_cell_n[i_cell_num] = cell_n[i];
              i_cell_id[i_cell_num] = i+1; //original cellpose id
              i_cell_num++;
            }

            current_cropping_tile++;
            if (current_cropping_tile < document.getElementById("ImageFiles2").files.length) LoadImage(current_cropping_cycle, current_cropping_tile, 0, 0, CroppingCallback);
            else
            {
              current_cropping_cycle = 2;
              current_cropping_tile = 0;
              LoadImage(current_cropping_cycle, current_cropping_tile, 0, 0, CroppingCallback);
            }
            return;
          }
          if (current_cropping_cycle == 2) // pheno mem
          {
            //retrieve the cell-id for every recognized cell:
            for (var i=0; i<p_cell_num; i++) if (p_cell_tile[i] == current_cropping_tile)
            {
              var x = p_cell_x[i];
              var y = p_cell_y[i];
              p_cell_id[i] = current_image_data[x+2048*y];
            }

            current_cropping_tile++;
            if (current_cropping_tile < document.getElementById("ImageFiles3").files.length) LoadImage(current_cropping_cycle, current_cropping_tile, 0, 0, CroppingCallback);
            else
            {
              AssignCells();
              SaveAssigments();
            }
          }
        }

        var cell_num = 0, cell_x, cell_y, cell_n;
        function DetectCells() //this function registers all nuclei from the currently loaded mask
        {
        	//find number of cells:
        	cell_num = 0;
        	for (var x=0; x<2048; x++) for (var y=0; y<2048; y++) if (current_image_data[x+2048*y] > cell_num) cell_num = current_image_data[x+2048*y];

        	//reserve memory:
        	cell_x = new Float32Array(cell_num);
        	cell_y = new Float32Array(cell_num);
        	cell_n = new Float32Array(cell_num);
        	cell_map = new Float32Array(cell_num);

        	//determine center of each cell:
        	for (var x=0; x<2048; x++) for (var y=0; y<2048; y++) if (current_image_data[x+2048*y] > 0)
        	{
        		cell = current_image_data[x+2048*y]-1;
        		cell_x[cell] += x;
        		cell_y[cell] += y;
        		cell_n[cell]++;
        	}
        	for (var cell=0; cell<cell_num; cell++)
        	{
        		cell_x[cell] /= cell_n[cell];
        		cell_y[cell] /= cell_n[cell];
        	}
        }

        var max_cell_num = 1000000*10;
        var p_cell_num = 0;
        var p_cell_tile = new Uint32Array(max_cell_num);
        var p_cell_x = new Uint32Array(max_cell_num);
        var p_cell_y = new Uint32Array(max_cell_num);
        var p_cell_n = new Uint32Array(max_cell_num);
        var p_cell_map = new Int32Array(max_cell_num);
        var p_cell_id = new Int32Array(max_cell_num);

        var i_cell_num = 0;
        var i_cell_tile = new Uint32Array(max_cell_num);
        var i_cell_x = new Uint32Array(max_cell_num);
        var i_cell_y = new Uint32Array(max_cell_num);
        var i_cell_n = new Uint32Array(max_cell_num);
        var i_cell_id = new Uint32Array(max_cell_num);


        var edge = 50; //less than overlap
        function AssignCells() //this function assigns closest nuclei between NIS and phenotype masks
        {
        	var scaling = document.getElementById("scaling").value*1;
          var maxdist = document.getElementById("maxdist").value*1;
          var px_per_step = document.getElementById("px_per_step").value*1;
          var py_per_step = document.getElementById("py_per_step").value*1;
          var use_overlapping_tiles = document.getElementById("use_overlapping_tiles").checked;
          var area_gating = document.getElementById("area_gating").checked;

        	for (var i=0; i<p_cell_num; i++)
        	{
        		var x = p_cell_x[i];
        		var y = p_cell_y[i];

            //transform phenotype position to matched NIS pos:
            var i_t = align_tile[p_cell_tile[i]];
            var i_x = (p_cell_x[i]-1024)/scaling+1024+align_x[p_cell_tile[i]];
            var i_y = (p_cell_y[i]-1024)/scaling+1024+align_y[p_cell_tile[i]];

            //find best in-situ tile:
            if (use_overlapping_tiles && i_t != -1)
            {
              var best_i_t = -1, best_fromcenter, best_i_x, best_i_y;
              for (var t=0; t<document.getElementById("ImageFiles2").files.length; t++)
              {
                var d_xstep = StagePositions1X[t]-StagePositions1X[i_t];
                var d_ystep = StagePositions1Y[t]-StagePositions1Y[i_t];

                if (d_xstep >= -1 && d_xstep <= 1 && d_ystep >= -1 && d_ystep <= 1)
                {
                  var i_xx = i_x - d_xstep*px_per_step - d_ystep*py_per_step;
                  var i_yy = i_y - d_xstep*py_per_step + d_ystep*px_per_step;

                  var fromcenter = (i_xx-1024)**2 + (i_yy-1024)**2;

                  if (best_i_t == -1 || fromcenter < best_fromcenter)
                  {
                    best_i_t = t;
                    best_fromcenter = fromcenter;
                    best_i_x = i_xx;
                    best_i_y = i_yy;
                  }
                }
              }
              i_t = best_i_t;
              i_x = best_i_x;
              i_y = best_i_y;
            }

        		var min_dist = 10000000, min_cell = -1;
        		if (x>edge && x<2048-edge && y>edge && y<2048-edge) //ignore edge cells
        			for (var ii=0; ii<i_cell_num; ii++)
                if (i_cell_tile[ii] == i_t)
        		{
        			var dx = i_x-i_cell_x[ii];
        			var dy = i_y-i_cell_y[ii];
        			var d = dx*dx + dy*dy;

        			var rel_area = p_cell_n[i] / i_cell_n[ii] /scaling/scaling; // /7.55

        			if (d<maxdist*maxdist)
        				if ((!area_gating) || rel_area > 0.5 && rel_area < 2)
        					if (min_cell == -1 || d < min_dist)
        			{
        				min_dist = d;
        				min_cell = ii;
        			}
        		}
        		p_cell_map[i] = min_cell;
        	}

        	//remove pheno cells mapping to the same in-situ cell:
        	var i_cell_match_count = new Uint32Array(i_cell_num);
        	for (var i=0; i<p_cell_num; i++) i_cell_match_count[p_cell_map[i]]++;
        	for (var i=0; i<p_cell_num; i++) if (i_cell_match_count[p_cell_map[i]] > 1) p_cell_map[i] = -1;

          //count success rate:
          var total_mapped = 0;
          for (var i=0; i<p_cell_num; i++) if (p_cell_map[i] != -1) total_mapped++;
          alert("Mapped: "+Math.round(total_mapped/p_cell_num*100*10)/10+"%");
        }

        function SaveAssigments() //this function saves the assignment results to a file
        {
          var out = "in-situ_tile\tin-situ_nucleus\tin-situ_nucleus_x\tin-situ_nucleus_y\tin-situ_nucleus_area\tphenotype_tile\tphenotype_cell\tphenotype_nucleus_x\tphenotype_nucleus_y\tphenotype_nucleus_area";
          for (var i=0; i<p_cell_num; i++)
          {
            var ii = p_cell_map[i];
            if (ii > -1) out += "\n"+i_cell_tile[ii]+"\t"+i_cell_id[ii]+"\t"+i_cell_x[ii]+"\t"+i_cell_y[ii]+"\t"+i_cell_n[ii]+"\t"+p_cell_tile[i]+"\t"+p_cell_id[i]+"\t"+p_cell_x[i]+"\t"+p_cell_y[i]+"\t"+p_cell_n[i];
          }
          SaveFile(out, "CellAssignments.txt");

          //mapping rate per tile:
          var num_tiles1 = document.getElementById("ImageFiles1").files.length;
          var tile_n = new Uint32Array(num_tiles1);
          var tile_mapped = new Uint32Array(num_tiles1);
          for (var i=0; i<p_cell_num; i++)
          {
            tile_n[p_cell_tile[i]]++;
            if (p_cell_map[i] != -1) tile_mapped[p_cell_tile[i]]++;
          }
          var out = "cells\tmapped";
          for (var i=0; i<num_tiles1; i++) out += "\n"+tile_n[i]+"\t"+tile_mapped[i];
          SaveFile(out, "TileAssignmentStats.txt");
        }


    </script>
