


<!--
==============================================================================

Copyright 2020-2024 by Jonathan Schmid-Burgk

==============================================================================
-->


<meta http-equiv="Content-Script-Type" content="text/javascript">
<META HTTP-EQUIV="CACHE-CONTROL" CONTENT="NO-CACHE">
    <html>
        <head>
            <title>ImageFiend 1.0</title>
        </head>
        <body style="margin: 0; font-family: Helvetica; font-weight: 100; background-size: 200vw 200vh" background="brown1.jpg">
          <div style="background-color: rgba(255,255,255,0.2); margin: 0.5%; padding: 1%; width: 47.25%; height: 100%">
            <b>NIS-Seq Analysis Suite v1.0 - Quantify correlation phenotype for each cell</b>
            <br>JSB lab 2020-2024
            <br>

            <br>Phenotype cell masks (TIFF, 1 channel, 2048x2048, 16 bit, sorted by tile):
            <br><input type="file" id="ImageFiles1" multiple/>
            
            <br>
            <br>Phenotype images (TIFF, 3 channels, 2048x2048, 16 bit, sorted by tile > channel):
            <br><input type="file" id="ImageFiles2" multiple/>

            <br>
            <br>
            <button onclick="StartCropping();">Start Analysis</button>
          </div>

          <div style="position:absolute; top:0; right:0; background-color: rgba(255,255,255,0.2); margin: 0.5%; padding: 1%; width: 47.25%; height: 100%">
            <b>Inspect raw images:</b>
            <br><br>
            <canvas id="maincanvas" width=2048 height=2048 style="width: 40vw; height: 40vw"></canvas>
            <br>
            <br><input type="range" id="cycle" min="0" max="1" onchange="UpdateCanvas()" /> Type (masks / raw images)
            <br><input type="range" min="0" max="2000" value="0" id="tile" onchange="UpdateCanvas()" /> Tile
            <br><input type="range" min="0" max="3" value="0" id="channel" onchange="UpdateCanvas()" /> Channel
            <br><input type="range" min="0" max="4" step="0.001" id="brightness" onchange="UpdateCanvas()" /> Brightness
          </div>
          
          <div id="status" style="position:absolute; bottom:0; left:0"></div>
          <div id="save" style = "display:none">test</div>
        </body>
    </html>


    <script type="text/javascript" src="pako.js"></script>
    <script type="text/javascript" src="UTIF.js"></script>
    <script type="text/javascript" src="UPNG.js"></script>

    <script>

        /// GENERAL PUROPSE FUNCTIONS ///

        function UpdateCanvas() //this callback function reads the GUI and updates the presented raw image
        {
          var cycle = document.getElementById("cycle").value*1;
          var tile = document.getElementById("tile").value*1;
          var channel = document.getElementById("channel").value*1;

          LoadImage(cycle, tile, channel, 0, 0);
        }

        var current_image_data;
        function LoadImage(cycle, tile, channel, filter, callback) //this function loads a specific raw image
        {
          var brightness = document.getElementById("brightness").value*1;

          var files = document.getElementById("ImageFiles1").files;
          var image_id;
          var file_id;
          var tile_p = tile;

          if (cycle==1) //phenotype
          {
              files = document.getElementById("ImageFiles2").files;
              file_id = tile*3 + channel;
          }
          else //cell mask
          {
            file_id = tile*1;
          }

          var reader = new FileReader();
          reader.onload = function(evt)
          {
            //decode TIFF:
            var ifds = UTIF.decode(reader.result);
            UTIF.decodeImage(reader.result, ifds[0]);
            var data = new Uint16Array(ifds[0].data);
            current_image_data = new Uint16Array(2048*2048);
            for (var i=0; i<2048*2048; i++) current_image_data[i] = data[i*2] + 256*data[i*2+1];

            //get access to main canvas object:
            var canvas = document.getElementById("maincanvas");
            var ImageContext = canvas.getContext("2d");
            var ImageData = ImageContext.getImageData(0, 0, 2048, 2048);
            var ImageArray = new Uint8Array(ImageData.data.buffer);

            //determine the max pixel intensity:
            var max = 0;
            for (var x=0; x<2048; x++) for (var y=0; y<2048; y++)
            {
              var xx = x;
              var yy = y;

              if (xx>=0 && xx<2048 && yy>=0 && yy<2048)
                if (current_image_data[x+y*2048] > max) max = current_image_data[xx+yy*2048];
            }

            //scale image brightness to 0-255:
            for (var x=0; x<2048; x++) for (var y=0; y<2048; y++)
            {
                var index = x+2048*y;

                var val = 0;

                var xx = x;
                var yy = y;

                if (xx >= 0 && yy >= 0 && xx < 2048 && yy < 2048) val = current_image_data[xx+2048*yy]/max*255 *brightness;
                if (val > 255) val = 255;

                ImageArray[4*index+0] = val;
                ImageArray[4*index+1] = val;
                ImageArray[4*index+2] = val;
                ImageArray[4*index+3] = 255;

                if (cell_highlighted[mask_image[x+2048*y]]) ImageArray[4*index+0] = 255;
            }

            //show scaled image:
            ImageContext.putImageData(ImageData, 0, 0);

            if (callback) callback();
          };
          reader.readAsArrayBuffer(files[file_id]);
        }

        function SaveFile(data, filename) //this function saves the content of data to a file
        {
            var bb = new Blob([data], {type: 'text/plain'});
            var a = document.createElement('a');
            a.download = filename;
            a.href = window.URL.createObjectURL(bb);
            a.textContent = 'Klick here to save';
            a.dataset.downloadurl = ['text/plain', a.download, a.href].join(':');
            document.getElementById("save").appendChild(a);
            a.click();
        }




        /// PHENOTYPE QUANTIFICATION ///

        var current_cropping_cycle = 0, current_cropping_tile = 0, current_cropping_channel = 0;
        var cropping_image_data = [];
        var cropping_stop;
        function StartCropping() //this function initiates a callback loop to phenotype all images
        {
          out = "tile\tcell\tx\ty\tcell_area\tnuc\tgfp\tnuc_norm\tgfp_norm\tcorrelation\n";
          current_cropping_cycle = 0;
          current_cropping_tile = 0;
          current_cropping_channel = 0;
          cropping_stop = 0;
          LoadImage(current_cropping_cycle, current_cropping_tile, current_cropping_channel, 0, CroppingCallback);
        }

        var nuc_image = new Float32Array(2048*2048), gfp_image = new Float32Array(2048*2048), mask_image = new Float32Array(2048*2048);
        function CroppingCallback() //this callback function loads the next image, starts the phenotyping, or saves the final results
        {
          if (cropping_stop) return;
          document.getElementById("status").innerHTML = current_cropping_cycle+" "+current_cropping_tile+" "+current_cropping_channel;

          if (current_cropping_cycle == 0) //mask
          {
            for (var i=0; i<2048*2048; i++) mask_image[i] = current_image_data[i];

            current_cropping_cycle = 1; //type = images
            current_cropping_channel = 0; //nuc
            LoadImage(current_cropping_cycle, current_cropping_tile, current_cropping_channel, 0, CroppingCallback);
          }
          else if (current_cropping_channel == 0) //confocal nuc
          {
            for (var i=0; i<2048*2048; i++) nuc_image[i] = current_image_data[i];

            current_cropping_channel = 1; //gfp
            LoadImage(current_cropping_cycle, current_cropping_tile, current_cropping_channel, 0, CroppingCallback);
          }
          else //confocal gfp
          {
            for (var i=0; i<2048*2048; i++) gfp_image[i] = current_image_data[i];
            
            QuantifyPhenotypes();

            current_cropping_cycle = 0; //mask
            current_cropping_channel = 0;
            current_cropping_tile++;

            if (current_cropping_tile < document.getElementById("ImageFiles1").files.length) LoadImage(current_cropping_cycle, current_cropping_tile, current_cropping_channel, 0, CroppingCallback);
            else
            {
              SaveFile(out, "Phenotypes.txt");
              alert("done");               
            }
          }
        }

        var out;
        function QuantifyPhenotypes() //this function determines the pixel-wise correlaton between GFP and nuclear images across cells in a loaded tile
        {
          //mask: mask_image
          //data: nuc_image, gfp_image

          //reserve memory:
          cell_area = new Float32Array(10000);
          cell_x = new Float32Array(10000);
          cell_y = new Float32Array(10000);
          cell_nuc_sum = new Float32Array(10000);
          cell_gfp_sum = new Float32Array(10000);
          cell_nuc2_sum = new Float32Array(10000);
          cell_gfp2_sum = new Float32Array(10000);
          cell_nuc_gfp_sum = new Float32Array(10000);
          var cellnum = 0;

          //integrate signal per cell:
          for (var x=0; x<2048; x++) for (var y=0; y<2048; y++) 
          {
            var cell = mask_image[x+y*2048];
            if (cell > 0)
            {
              cell_area[cell]++;
              cell_x[cell] += x;
              cell_y[cell] += y;
              cell_nuc_sum[cell] += nuc_image[x+y*2048];
              cell_gfp_sum[cell] += gfp_image[x+y*2048];
              cell_nuc2_sum[cell] += nuc_image[x+y*2048]**2;
              cell_gfp2_sum[cell] += gfp_image[x+y*2048]**2;
              cell_nuc_gfp_sum[cell] += nuc_image[x+y*2048] * gfp_image[x+y*2048];

              if (cell > cellnum) cellnum = cell;
            }
          }

          //output list:
          for (var cell=1; cell<cellnum; cell++)
          {
            var n = cell_area[cell];
            var xsum = cell_nuc_sum[cell];
            var ysum = cell_gfp_sum[cell];
            var xxsum = cell_nuc2_sum[cell];
            var yysum = cell_gfp2_sum[cell];
            var xysum = cell_nuc_gfp_sum[cell];
            var r = (n*xysum-xsum*ysum)/(Math.sqrt(n*xxsum-xsum*xsum)*Math.sqrt(n*yysum-ysum*ysum));

            out += current_cropping_tile+"\t"+cell+"\t"+
                   Math.floor(cell_x[cell]/cell_area[cell])+"\t"+Math.floor(cell_y[cell]/cell_area[cell])+"\t"+
                   cell_area[cell]+"\t"+
                   cell_nuc_sum[cell]+"\t"+cell_gfp_sum[cell]+"\t"+cell_nuc_sum[cell]/cell_area[cell]+"\t"+cell_gfp_sum[cell]/cell_area[cell]+"\t"+
                   r+"\n";
          } 
        }

    </script>
