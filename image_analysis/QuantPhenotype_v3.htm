


<!--
==============================================================================

Copyright 2020-2024 by Jonathan Schmid-Burgk

==============================================================================
-->


<meta http-equiv="Content-Script-Type" content="text/javascript">
<META HTTP-EQUIV="CACHE-CONTROL" CONTENT="NO-CACHE">
    <html>
        <head>
            <title>ImageFiend 1.0</title>
        </head>
        <body style="margin: 0; font-family: Helvetica; font-weight: 100; background-size: 200vw 200vh" background="brown1.jpg">
          <div style="background-color: rgba(255,255,255,0.2); margin: 0.5%; padding: 1%; width: 47.25%; height: 100%">
            <b>NIS-Seq Analysis Suite v1.0 - Quantify specking phenotype for each cell</b>
            <br>JSB lab 2020-2024
            <br>

            <br>Phenotype cell masks (TIFF, 1 channel, 2048x2048, 16 bit, sorted by tile):
            <br><input type="file" id="ImageFiles1" multiple/>
            
            <br>
            <br>Phenotype images (TIFF, 1 channel, 2048x2048, 16 bit, sorted by tile):
            <br><input type="file" id="ImageFiles2" multiple/>

            <br>
            <br>
            <button onclick="StartCropping();">Start Analysis</button>
          </div>

          <div style="position:absolute; top:0; right:0; background-color: rgba(255,255,255,0.2); margin: 0.5%; padding: 1%; width: 47.25%; height: 100%">
            <b>Inspect raw images:</b>
            <br><br>
            <canvas id="maincanvas" width=2048 height=2048 style="width: 40vw; height: 40vw"></canvas>
            <br>
            <br><input type="range" id="cycle" min="0" max="1" onchange="UpdateCanvas()" /> Type (masks / raw images)
            <br><input type="range" min="0" max="2000" value="0" id="tile" onchange="UpdateCanvas()" /> Tile
            <br><input type="range" min="0" max="3" value="0" id="channel" onchange="UpdateCanvas()" /> Channel
            <br><input type="range" min="0" max="4" step="0.001" id="brightness" onchange="UpdateCanvas()" /> Brightness
            <br><input type="checkbox" id="background_subtraction" onchange="UpdateCanvas();" checked/> background subtraction
          </div>

          <div id="status" style="position:absolute; bottom:0; left:0"></div>
          <div id="save" style = "display:none">test</div>
        </body>
    </html>


    <script type="text/javascript" src="pako.js"></script>
    <script type="text/javascript" src="UTIF.js"></script>
    <script type="text/javascript" src="UPNG.js"></script>

    <script>

        /// GENERAL PUROPSE FUNCTIONS ///

        function UpdateCanvas() //this callback function reads the GUI and updates the presented raw image
        {
          var cycle = document.getElementById("cycle").value*1;
          var tile = document.getElementById("tile").value*1;
          var channel = document.getElementById("channel").value*1;

          LoadImage(cycle, tile, channel, 0, 0);
        }

        var current_image_data;
        function LoadImage(cycle, tile, channel, filter, callback) //this function loads a specific raw image
        {
          var brightness = document.getElementById("brightness").value*1;

          var files = document.getElementById("ImageFiles1").files;
          var image_id;
          var file_id;
          var tile_p = tile;

          if (cycle==1) //phenotype
          {
              files = document.getElementById("ImageFiles2").files;
              file_id = tile + channel;
          }
          else //cell mask
          {
            file_id = tile*1;
          }

          var reader = new FileReader();
          reader.onload = function(evt)
          {
            //decode TIFF:
            var ifds = UTIF.decode(reader.result);
            UTIF.decodeImage(reader.result, ifds[0]);
            var data = new Uint16Array(ifds[0].data);
            current_image_data = new Uint16Array(2048*2048);
            for (var i=0; i<2048*2048; i++) current_image_data[i] = data[i*2] + 256*data[i*2+1];

            //get access to main canvas object:
            var canvas = document.getElementById("maincanvas");
            var ImageContext = canvas.getContext("2d");
            var ImageData = ImageContext.getImageData(0, 0, 2048, 2048);
            var ImageArray = new Uint8Array(ImageData.data.buffer);

            //optional: background subtraction
            var background_subtraction = document.getElementById("background_subtraction").checked;
            if (background_subtraction && cycle==1)
            {
              //downsample 8x:
              var downsampled = new Float32Array(256*256);
              for (var x=0; x<2048; x++) for (var y=0; y<2048; y++)
              {
                var xx = Math.floor(x/8);
                var yy = Math.floor(y/8);
                downsampled[xx+256*yy] += current_image_data[x+y*2048] / 64;
              }
              //find lowest px in 9x9 grid:
              for (var x=0; x<2048; x++) for (var y=0; y<2048; y++)
              {
                var xx = Math.floor(x/8);
                var yy = Math.floor(y/8);
                var minval = 1000000;
                for (var dx=-4; dx<=4; dx++)
                  if (xx+dx >= 0 && xx+dx < 256)
                    for (var dy=-4; dy<=4; dy++)
                      if (yy+dy >= 0 && yy+dy < 256)
                {
                  var val = downsampled[xx+dx+256*(yy+dy)];
                  if (val < minval) minval = val;
                }
                //subtract:
                if (current_image_data[x+y*2048]>minval) current_image_data[x+y*2048] -= minval;
                else current_image_data[x+y*2048] = 0;
              }
            }

            //determine the max pixel intensity:
            var max = 0;
            for (var x=0; x<2048; x++) for (var y=0; y<2048; y++)
            {
              var xx = x;
              var yy = y;

              if (xx>=0 && xx<2048 && yy>=0 && yy<2048)
                if (current_image_data[x+y*2048] > max) max = current_image_data[xx+yy*2048];
            }

            //scale image brightness to 0-255:
            for (var x=0; x<2048; x++) for (var y=0; y<2048; y++)
            {
                var index = x+2048*y;

                var val = 0;

                var xx = x;
                var yy = y;

                if (xx >= 0 && yy >= 0 && xx < 2048 && yy < 2048) val = current_image_data[xx+2048*yy]/max*255 *brightness;
                if (val > 255) val = 255;

                ImageArray[4*index+0] = val;
                ImageArray[4*index+1] = val;
                ImageArray[4*index+2] = val;
                ImageArray[4*index+3] = 255;

                if (cell_highlighted[mask_image[x+2048*y]]) ImageArray[4*index+0] = 255;
            }

            //show scaled image:
            ImageContext.putImageData(ImageData, 0, 0);

            if (callback) callback();
          };
          reader.readAsArrayBuffer(files[file_id]);
        }

        function SaveFile(data, filename) //this function saves the content of data to a file
        {
            var bb = new Blob([data], {type: 'text/plain'});
            var a = document.createElement('a');
            a.download = filename;
            a.href = window.URL.createObjectURL(bb);
            a.textContent = 'Klick here to save';
            a.dataset.downloadurl = ['text/plain', a.download, a.href].join(':');
            document.getElementById("save").appendChild(a);
            a.click();
        }



        /// PHENOTYPE QUANTIFICATION ///

        var current_cropping_cycle = 0, current_cropping_tile = 0, current_cropping_channel = 0;
        var cropping_image_data = [];
        var cropping_stop;
        function StartCropping() //this function initiates a callback loop to phenotype all images
        {
          out = "tile\tcell\tx\ty\tcell_area\tgfp\tgfp_spots\tgfp_norm\tspots_norm\n";
          current_cropping_cycle = 0;
          current_cropping_tile = 0;
          current_cropping_channel = 0;
          cropping_stop = 0;
          LoadImage(current_cropping_cycle, current_cropping_tile, current_cropping_channel, 0, CroppingCallback);
        }

        var sum_gfp_image = new Float32Array(2048*2048), mask_image = new Float32Array(2048*2048);
        function CroppingCallback() //this callback function loads the next image, starts the phenotyping, or saves the final results
        {
          if (cropping_stop) return;
          document.getElementById("status").innerHTML = current_cropping_cycle+" "+current_cropping_tile+" "+current_cropping_channel;

          if (current_cropping_cycle == 0) //mask
          {
            current_cropping_cycle = 1; //type = images
            current_cropping_channel = 0; //there is only one
            for (var i=0; i<2048*2048; i++) mask_image[i] = current_image_data[i];
            for (var i=0; i<2048*2048; i++) sum_gfp_image[i] = 0;
            LoadImage(current_cropping_cycle, current_cropping_tile, current_cropping_channel, 0, CroppingCallback);
          }
          else //confocal
          {
            for (var i=0; i<2048*2048; i++) sum_gfp_image[i] = current_image_data[i];
            
            QuantifyPhenotypes();

            current_cropping_cycle = 0; //mask
            current_cropping_channel = 0;
            current_cropping_tile++;

            if (current_cropping_tile < document.getElementById("ImageFiles1").files.length) LoadImage(current_cropping_cycle, current_cropping_tile, current_cropping_channel, 0, CroppingCallback);
            else
            {
              SaveFile(out, "Phenotypes.txt");
              alert("done");               
            }
          }
        }

        var out;
        var cell_area, cell_gfp_sum, cell_gfp_spot_sum;
        function QuantifyPhenotypes() //this function determines the intensity of GFP across cells in a loaded tile, both with and without high-pass frequency filter
        {
          //mask: mask_image
          //data: sum_gfp_image

          //reserve memory:
          cell_area = new Float32Array(10000);
          var cell_x = new Float32Array(10000);
          var cell_y = new Float32Array(10000);
          cell_gfp_sum = new Float32Array(10000);
          cell_gfp_spot_sum = new Float32Array(10000);
          var cellnum = 0;

          //high-pass frequency filter:
          var sum_gfp_highpass = new Float32Array(2048*2048);
          var LP1 = new Float32Array(2048*2048), LP2 = new Float32Array(2048*2048);
          for (var x=0; x<2048; x++) for (var y=0; y<2048; y++) LP1[x+y*2048] = sum_gfp_image[x+y*2048];
          for (var round=0; round<3; round++)
          {
            for (var x=0; x<2048-1; x++) for (var y=0; y<2048; y++) LP1[x+y*2048] = (LP1[x+y*2048]+LP1[x+1+y*2048])/2;
            for (var x=2048-1; x>0; x--) for (var y=0; y<2048; y++) LP1[x+y*2048] = (LP1[x+y*2048]+LP1[x-1+y*2048])/2;
            for (var y=0; y<2048-1; y++) for (var x=0; x<2048; x++) LP1[x+y*2048] = (LP1[x+y*2048]+LP1[x+(y+1)*2048])/2;
            for (var y=2048-1; y>0; y--) for (var x=0; x<2048; x++) LP1[x+y*2048] = (LP1[x+y*2048]+LP1[x+(y-1)*2048])/2;

            if (round == 0) for (var x=0; x<2048; x++) for (var y=0; y<2048; y++) LP2[x+y*2048] = LP1[x+y*2048];
          }
          for (var x=0; x<2048; x++) for (var y=0; y<2048; y++)
          {
            if (LP2[x+y*2048] > LP1[x+y*2048]) sum_gfp_highpass[x+y*2048] = LP2[x+y*2048] - LP1[x+y*2048];
            else sum_gfp_highpass[x+y*2048] = 0;
          }

          //integrate signal per cell:
          for (var x=0; x<2048; x++) for (var y=0; y<2048; y++) 
          {
            var cell = mask_image[x+y*2048];
            if (cell > 0)
            {
              cell_area[cell]++;
              cell_x[cell] += x;
              cell_y[cell] += y;
              cell_gfp_sum[cell] += sum_gfp_image[x+y*2048];
              cell_gfp_spot_sum[cell] += sum_gfp_highpass[x+y*2048];
              if (cell > cellnum) cellnum = cell;
            }
          }

          //output list:
          for (var cell=1; cell<cellnum; cell++) out += current_cropping_tile+"\t"+cell+"\t"+Math.floor(cell_x[cell]/cell_area[cell])+"\t"+Math.floor(cell_y[cell]/cell_area[cell])+"\t"+cell_area[cell]+"\t"+cell_gfp_sum[cell]+"\t"+cell_gfp_spot_sum[cell]+"\t"+cell_gfp_sum[cell]/cell_area[cell]+"\t"+cell_gfp_spot_sum[cell]/cell_area[cell]+"\n";
        }

    </script>
