


<!--
==============================================================================

Copyright 2020-2024 by Jonathan Schmid-Burgk

==============================================================================
-->


<meta http-equiv="Content-Script-Type" content="text/javascript">
<META HTTP-EQUIV="CACHE-CONTROL" CONTENT="NO-CACHE">
    <html>
        <head>
            <title>ImageFiend 1.0</title>
        </head>
        <body style="margin: 0; font-family: Helvetica; font-weight: 100; background-size: 200vw 200vh" background="brown1.jpg">
          <div style="background-color: rgba(255,255,255,0.2); margin: 0.5%; padding: 1%; width: 47.25%; height: 100%">
            <b>NIS-Seq Analysis Suite v1.0 - Obtain collages of lists of selected cells</b>
            <br>JSB lab 2020-2024
            <br>

            <br>Phenotype cell masks (TIFF, 1 channel, 2048x2048, 16 bit, sorted by tile):
            <br><input type="file" id="ImageFiles1" multiple/>
            
            <br>
            <br>Phenotype images (TIFF, 2048x2048, 16 bit, sorted by channel > tile):
            <br><input type="file" id="ImageFiles2" multiple/>
            <br>Channels: <input id="collage_channels" value="3" />


            <br>
            <br>List of cells to be included in collages:
            <br><input type="file" id="CellFile" onchange="LoadCellFile();" /> (tab delimited, tile - cell - x - y - sequence/gene)

            <br>
            <br>Limit number of collages: <input id="limit_collages_num" value="1000" />
            <br>Tile size for each cell: <input id="collage_tile_size" value="70" /> px
            <br>Collage rows size: <input id="collage_rows" value="3" /> (e.g. 5 means obtaining 5x5 grids)
            <br>Collage color channel: <input id="collage_channel" value="2" /> (counting from 1)
            <br>Enlarge masks by 2 pixels: <input type="checkbox" id="enlarge_mask" />
            <br>Scale down 2-fold: <input type="checkbox" id="scale_down" checked /> 
            <br>Overwrite tiles: <input type="checkbox" id="overwrite_tiles" checked /> 
            <br>
            <button onclick="StartCropping();">Aggregate collages in memory</button>
            <button onclick="cropping_stop=1;">Stop</button>

            <br>
            <br>Minimum cells per collage: <input id="minimum_cells" value="3" />
            <br>Maximum cells per collage: <input id="maximum_cells" value="1000" />
            <br>Limit files to be saved: <input id="limit_save_collages_num" value="20" />
            <br><button onclick="SaveAllImages();">Save Collages</button>
          </div>

          <div style="position:absolute; top:0; right:0; background-color: rgba(255,255,255,0.2); margin: 0.5%; padding: 1%; width: 47.25%; height: 100%">
            <b>Inspect raw images:</b>
            <br><br>
            <canvas id="maincanvas" width=2048 height=2048 style="width: 40vw; height: 40vw"></canvas>
            <br>
            <br><input type="range" id="cycle" min="0" max="1" onchange="UpdateCanvas()" /> Type (masks / raw images)
            <br><input type="range" min="0" max="2000" value="0" id="tile" onchange="UpdateCanvas()" /> Tile
            <br><input type="range" min="0" max="3" value="0" id="channel" onchange="UpdateCanvas()" /> Channel
            <br><input type="range" min="0" max="4" step="0.001" id="brightness" onchange="UpdateCanvas()" /> Brightness
          </div>


          <div id="status" style="position:absolute; bottom:0; left:0"></div>
          <div id="save" style = "display:none">test</div>
        </body>
    </html>


    <script type="text/javascript" src="pako.js"></script>
    <script type="text/javascript" src="UTIF.js"></script>
    <script type="text/javascript" src="UPNG.js"></script>

    <script>

        /// GENERAL PUROPSE FUNCTIONS ///

        var num_tiles1 = 0;

        function UpdateCanvas() //this callback function reads the GUI and updates the presented raw image
        {
          var cycle = document.getElementById("cycle").value*1;
          var tile = document.getElementById("tile").value*1;
          var channel = document.getElementById("channel").value*1;

          LoadImage(cycle, tile, channel, 0, 0);
        }

        var current_image_data;
        function LoadImage(cycle, tile, channel, filter, callback) //this function loads a specific raw image
        {
          var brightness = document.getElementById("brightness").value*1;

          var files = document.getElementById("ImageFiles1").files;
          var image_id;
          var file_id;
          var tile_p = tile;

          if (cycle==1) //phenotype
          {
              files = document.getElementById("ImageFiles2").files;
              file_id = tile*collage_channels + channel;
          }
          else //cell mask
          {
            file_id = tile*1;
          }

          var reader = new FileReader();
          reader.onload = function(evt)
          {
            //decode TIFF:
            var ifds = UTIF.decode(reader.result);
            UTIF.decodeImage(reader.result, ifds[0]);
            var data = new Uint16Array(ifds[0].data);
            current_image_data = new Uint16Array(2048*2048);
            for (var i=0; i<2048*2048; i++) current_image_data[i] = data[i*2] + 256*data[i*2+1];

            //store data for later:
            cropping_image_data[current_cropping_cycle+current_cropping_channel] = current_image_data; //0-4

            //get access to main canvas object:
            var canvas = document.getElementById("maincanvas");
            var ImageContext = canvas.getContext("2d");
            var ImageData = ImageContext.getImageData(0, 0, 2048, 2048);
            var ImageArray = new Uint8Array(ImageData.data.buffer);

            //determine the max pixel intensity:
            var max = 0;
            for (var x=0; x<2048; x++) for (var y=0; y<2048; y++)
            {
              var xx = x;
              var yy = y;

              if (xx>=0 && xx<2048 && yy>=0 && yy<2048)
                if (current_image_data[x+y*2048] > max) max = current_image_data[xx+yy*2048];
            }

            //scale image brightness to 0-255:
            for (var x=0; x<2048; x++) for (var y=0; y<2048; y++)
            {
                var index = x+2048*y;

                var val = 0;

                var xx = x;
                var yy = y;

                if (xx >= 0 && yy >= 0 && xx < 2048 && yy < 2048) val = current_image_data[xx+2048*yy]/max*255 *brightness;
                if (val > 255) val = 255;

                ImageArray[4*index+0] = val;
                ImageArray[4*index+1] = val;
                ImageArray[4*index+2] = val;
                ImageArray[4*index+3] = 255;
            }
    
            //show scaled image:
            ImageContext.putImageData(ImageData, 0, 0);

            if (callback) callback();
          };
          reader.readAsArrayBuffer(files[file_id] /*.slice(start, start+2048*2048*2)*/ );
        }

        function SaveFile(data, filename) //this function saves the content of data to a file
        {
            var bb = new Blob([data], {type: 'text/plain'});
            var a = document.createElement('a');
            a.download = filename;
            a.href = window.URL.createObjectURL(bb);
            a.textContent = 'Klick here to save';
            a.dataset.downloadurl = ['text/plain', a.download, a.href].join(':');
            document.getElementById("save").appendChild(a);
            a.click();
        }

        function SaveImage(name, ch) //this function saves an image to a local PNG file
        {
          var filename = name+"_"+collages_counter[name]+".png";

          var input_image8 = new Uint8Array(collages[name].buffer);
          var inverted = new Uint8Array(collage_tile_size*collage_rows*collage_tile_size*collage_rows*2);
          for (var x=0; x<collage_tile_size*collage_rows; x++)
            for (var y=0; y<collage_tile_size*collage_rows; y++)
            {
              inverted[x*2 + y*collage_tile_size*collage_rows*2   ] = input_image8[ch*collage_rows*collage_rows*collage_tile_size*collage_tile_size*2 + x*2 + y*collage_tile_size*collage_rows*2 +1];
              inverted[x*2 + y*collage_tile_size*collage_rows*2 +1] = input_image8[ch*collage_rows*collage_rows*collage_tile_size*collage_tile_size*2 + x*2 + y*collage_tile_size*collage_rows*2   ];
            }

          var dummy = [];
          dummy[0] = inverted.buffer;

          //save as PNG (load multipage PNG in imageJ with bioformat importer):
          var newimage = UPNG.encodeLL(dummy, collage_tile_size*collage_rows, collage_tile_size*collage_rows, 1, 0, 16, 1000); //data, w, h, colors, alphas, bits, milliseconds per frame
          var bb = new Blob([newimage], {type: 'application/octet-stream'});
          var a = document.createElement('a');
          a.download = filename;
          a.href = window.URL.createObjectURL(bb);
          a.textContent = 'Klick here to save';
          a.dataset.downloadurl = ['text/plain', a.download, a.href].join(':');
          document.getElementById("save").appendChild(a);
          a.click();
        }



        /// COLLAGE ASSEMBLY ///

        var cells = 0;
        function LoadCellFile() //this function loads a list of cells to be captured in assembled collages
        {
          var reader = new FileReader();
          reader.onload = function(evt)
          {
            var table = reader.result.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");

            cell_tile = new Uint16Array(table.length-1);
            cell_cell = new Uint16Array(table.length-1);
            cell_x = new Int16Array(table.length-1);
            cell_y = new Int16Array(table.length-1);
            cell_seq = [];

            cells = 0;
            for (var i=1; i<table.length; i++)
            {
              var line = table[i].split("\t");
              if (line.length >= 4)
              {
                cell_tile[cells] = line[0]*1;
                cell_cell[cells] = line[1]*1;
                cell_x[cells] = line[2]*1;
                cell_y[cells] = line[3]*1;
                if (line.length > 4) cell_seq[cells] = line[4];
                else cell_seq[cells] = "all";

                cells++;
              }
            }
          };
          reader.readAsText(document.getElementById("CellFile").files[0]);
        }

        var current_cropping_cycle = 0, current_cropping_tile = 0, current_cropping_channel = 0;
        var cropping_image_data = [];
        var cropping_stop;
        var collage_rows = 3;
        var collage_tile_size = 300;
        var collage_channel = 2, collage_channels = 3;
        var enlarge_mask = false;
        var minimum_cells = 3;
        var scale_down = false;
        var overwrite_tiles = false;
        function StartCropping() //this function initiates a callback loop to load all images and copy the cells of interest to collages
        {
          num_tiles1=document.getElementById("ImageFiles1").files.length/1;
          collage_rows = document.getElementById("collage_rows").value*1;
          collage_tile_size = document.getElementById("collage_tile_size").value*1;
          collage_channel = document.getElementById("collage_channel").value*1 -1; //counting from 0
          collage_channels = document.getElementById("collage_channels").value*1;
          enlarge_mask = document.getElementById("enlarge_mask").checked;
          scale_down = document.getElementById("scale_down").checked;
          overwrite_tiles = document.getElementById("overwrite_tiles").checked;

          out = "";
          current_cropping_cycle = 0;
          current_cropping_tile = 0;
          current_cropping_channel = 0;
          cropping_stop = 0;
          LoadImage(current_cropping_cycle, current_cropping_tile, current_cropping_channel, 0, CroppingCallback);
        }

        function CroppingCallback() //this callback function loads the next image or starts the collage assembly
        {
          if (cropping_stop) return;
          document.getElementById("status").innerHTML = current_cropping_cycle+" "+current_cropping_tile+" "+current_cropping_channel;

          if (current_cropping_cycle == 0) //mask
          {
            current_cropping_cycle = 1;
            current_cropping_channel = 0;
            LoadImage(current_cropping_cycle, current_cropping_tile, current_cropping_channel, 0, CroppingCallback);
          }
          else //confocal
          {
            if (current_cropping_channel < collage_channels-1)
            {
              current_cropping_channel++;
              LoadImage(current_cropping_cycle, current_cropping_tile, current_cropping_channel, 0, CroppingCallback);
            }
            else //all data loaded
            {
              CropCells(current_cropping_tile);

              //speed up by passing tiles with no cell:
              var next=1;
              while (next && current_cropping_tile < num_tiles1)
              {
                current_cropping_tile++;
                for (var c=0; c<cell_tile.length; c++) if (cell_tile[c] == current_cropping_tile)
                {
                  next = 0;
                  break;
                }
              }

              current_cropping_cycle = 0;
              current_cropping_channel = 0;

              if (current_cropping_tile < num_tiles1) LoadImage(current_cropping_cycle, current_cropping_tile, current_cropping_channel, 0, CroppingCallback);
              else
              {
                alert("Done");               
              }
            }
          }
        }

        var collages = [], collages_counter = [], collages_num = 0;
        function CropCells(tile) //this function crops cells of interest from currently loaded tile and copies them to collages in memory
        {
          var limit_collages_num = document.getElementById("limit_collages_num").value*1;
          var scale = 1;
          if (scale_down) scale = 2;

          for (var c=0; c<cells; c++) if (cell_tile[c] == tile)
          {
            var cx = cell_x[c];
            var cy = cell_y[c];
            var mask = cropping_image_data[0][cx+2048*cy]; //cell_cell[c];
            var seq = cell_seq[c];

            if (mask != 0)
            {
              if (collages[seq] === undefined && collages_num < limit_collages_num)
              {
                collages[seq] = new Uint16Array(collage_rows*collage_rows * collage_tile_size*collage_tile_size /* *3 */);
                collages_counter[seq] = 0;
                collages_num++;
              }

              if (collages[seq] !== undefined)
              {
                var tileposition = collages_counter[seq];
                if (overwrite_tiles) tileposition = tileposition%(collage_rows*collage_rows);

                var collagex = tileposition%collage_rows;
                var collagey = Math.floor(tileposition/collage_rows);

                if (tileposition<collage_rows*collage_rows)
                {
                  for (var x=0; x<collage_tile_size*scale; x++) for (var y=0; y<collage_tile_size*scale; y++)
                  {
                    var xx = cx-Math.floor(collage_tile_size/2*scale)+x;
                    var yy = cy-Math.floor(collage_tile_size/2*scale)+y;

                    var win = 0;
                    if (cropping_image_data[0][xx+2048*yy] == mask) win = 1;

                    if (enlarge_mask)
                    {
                      var enlarge = 2;
                      for (var mx=xx-enlarge; mx<=xx+enlarge; mx+=2)
                        for (var my=yy-enlarge; my<=yy+enlarge; my+=2)
                          if (mx>=0 && mx<2048 && my>=0 && my<2048)
                            if (cropping_image_data[0][mx+2048*my] == mask) win = 1;
                    }

                    //add to collage:
                    if (xx>=0 && xx<2048 && yy>=0 && yy<2048)
                    {
                      var xxx = collage_tile_size*collagex + Math.floor(x/scale);
                      var yyy = collage_tile_size*collagey + Math.floor(y/scale);

                      collages[seq][xxx + collage_tile_size*collage_rows*yyy] = win*cropping_image_data[1+collage_channel][xx+2048*yy];
                    }
                  }
                }
                collages_counter[seq]++;
              }
            }
          }
        }

        function SaveAllImages() //this function saves all collages that are in memory to local PNG files
        {
          var limit_save_collages_num = document.getElementById("limit_save_collages_num").value*1; //can be changed
          minimum_cells = document.getElementById("minimum_cells").value*1;
          maximum_cells = document.getElementById("maximum_cells").value*1;

          var save_counter = 0;
          for (var name in collages) if (collages_counter[name] >= minimum_cells && collages_counter[name] <= maximum_cells && save_counter < limit_save_collages_num)
          {
            SaveImage(name, 0);
            save_counter++;
          }
        }


    </script>
