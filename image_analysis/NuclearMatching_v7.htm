


<!--
==============================================================================

Copyright 2020-2023 by Jonathan Schmid-Burgk

==============================================================================
-->


<meta http-equiv="Content-Script-Type" content="text/javascript">
<META HTTP-EQUIV="CACHE-CONTROL" CONTENT="NO-CACHE">
    <html>
        <head>
            <title>ImageFiend 1.0</title>
        </head>
        <body>

            <br>Phenotyping nuclear masks (1 channel, 2048x2048, 16bit):
            <br><input type="file" id="ImageFiles1" onchange="num_tiles1=this.files.length/1;" multiple/>
            <br>
            <br>Phenotyping membrane masks (1 channel, 2048x2048, 16bit):
            <br><input type="file" id="ImageFiles3" onchange="num_tiles3=this.files.length/1;" multiple/>
            <br>
            <br>In-Situ nuclear masks (1 channel, 2048x2048, 16bit):
            <br><input type="file" id="ImageFiles2" onchange="num_tiles2=this.files.length/1;" multiple/>
            <br>
            <br>Scaling factor: <input id="scaling" value="3"/>
            <br>Maximum cell movement (in-situ pixels): <input id="maxdist" value="33"/>
            <br>
            <br>Nuclear alignment file (tab delimited, pheno tile - insitu tile - x - y)
            <br>Start from phenotype tile: <input id="start_tile_p" value="0"/>
            <br>Start from in-situ tile: <input id="start_tile_is" value="0"/>
            <br>Area gating: <input type="checkbox" id="area_gating" checked/>
            <br><input type="file" id="AlignmentFile" /> <button onclick="LoadAlignmentFile();">load</button>
            <br>

            <br>If using overlapping tiles:
            <input type="checkbox" id="use_overlapping_tiles" checked/>
            <br><input type="file" id="StageFile1" /> Stage positions (time-well-tile-x-y in Âµm, with header, can be generic) <button onclick="LoadStageFile1();">load</button>
            <br>pixels per in-situ tile (x): <input id="px_per_step" value="1905"/> (adjusted to 20x objective with 1x lens)
            <br>pixels per in-situ tile (y): <input id="py_per_step" value="-45"/> (adjusted to 20x objective with 1x lens)

            <br>
            <br><button onclick="StartCropping();">Detect, assign, save cells </button>

            <br>
            <br>
            <br><input type="range" id="cycle" min="0" max="2" value="0" onchange="UpdateCanvas()" /> Type (insitu / phenotype)
            <br><input type="range" min="0" max="16000" value="0" id="tile" style="width:50%" onchange="UpdateCanvas()" /> Tile
            <br><input type="range" min="0" max="4" value="0" id="channel" onchange="UpdateCanvas()" /> Channel
            <br><input type="range" min="0" max="3" value="0.4" step="0.001" id="brightness" onchange="UpdateCanvas()" /> Brightness
            <br><input type="checkbox" id="showspots" onchange="UpdateCanvas()" /> Show Spots
            <br><input type="checkbox" id="showscaled" onchange="UpdateCanvas()" /> Show Scaled
            <br>
            <br>


            <div style="position:absolute; top:0; right:0"><canvas id="maincanvas" width=2048 height=2048 style="width:800px; height:800px"></canvas></div>
            <div id="status" style="position:absolute; bottom:0; left:0"></div>
            <div id="save" style = "display:none">test</div>
        </body>
    </html>

    <script type="text/javascript" src="pako.js"></script>
    <script type="text/javascript" src="UTIF.js"></script>
    <script>


        var align_x, align_y, align_tile, align_q;

        var num_tiles1 = 0;
        var num_tiles2 = 0;
        var num_tiles3 = 0;


        //LOAD STAGE POSITIONS:
        var StagePositions1X = [], StagePositions1Y = [];
        function LoadStageFile1()
        {
          var reader = new FileReader();
          reader.onload = function(evt)
          {
            var table = reader.result.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
            
            for (var i=0; i<table.length-1; i++)
            {
              var line = table[i+1].split("\t");

              StagePositions1X[i] = line[3+0]*1;
              StagePositions1Y[i] = line[3+1]*1;
            }

            //normalize to stage steps (assuming a simple grid, starting left-to-right):
            var StagePositionStep = StagePositions1X[1]-StagePositions1X[0];
            var StagePositionX0 = StagePositions1X[0];
            var StagePositionY0 = StagePositions1Y[0];
            for (var i=0; i<table.length-1; i++)
            {
              StagePositions1X[i] = Math.round((StagePositions1X[i]-StagePositionX0)/StagePositionStep);
              StagePositions1Y[i] = Math.round((StagePositions1Y[i]-StagePositionY0)/StagePositionStep);
            }
          };
          reader.readAsText(document.getElementById("StageFile1").files[0]);
        }





        function UpdateCanvas()
        {
          var cycle = document.getElementById("cycle").value*1;
          var tile = document.getElementById("tile").value*1;
          var channel = document.getElementById("channel").value*1;

          LoadImage(cycle, tile, channel, 0, 0);
        }

        var current_image_data;
        function LoadImage(cycle, tile, channel, filter, callback)
        {
          var brightness = document.getElementById("brightness").value*1;
          var scaling = document.getElementById("scaling").value*1;
          var showspots = document.getElementById("showspots").checked;
          var showscaled = document.getElementById("showscaled").checked;

          var files;
          var image_id = tile*1;
          var start = 256; //image_offsets1[image_id]; //VERY VERY VERY DIRTY
          //var tile_p = tile, tile_is = tile;


          if (cycle==0) //pheno
          {
            files = document.getElementById("ImageFiles1").files;
          }
          if (cycle==1) //insitu
          {
            files = document.getElementById("ImageFiles2").files;
            if (showscaled) image_id = align_tile[tile*1];
          }
          if (cycle==2) //pheno mem
          {
            files = document.getElementById("ImageFiles3").files;
          }


          var reader = new FileReader();
          reader.onload = function(evt)
          {
            //decode TIF:
            var ifds = UTIF.decode(reader.result);
            UTIF.decodeImage(reader.result, ifds[0]);
            var data = new Uint16Array(ifds[0].data);
            current_image_data = new Uint16Array(2048*2048);
            for (var i=0; i<2048*2048; i++) current_image_data[i] = data[i*2] + 256*data[i*2+1];

            var canvas = document.getElementById("maincanvas");
            //canvas.width = 1024;
            //canvas.height = 1024;
            var ImageContext = canvas.getContext("2d");
            var ImageData = ImageContext.getImageData(0, 0, 2048, 2048);
            var ImageArray = new Uint8Array(ImageData.data.buffer);

            var max = 0;
            for (var x=0; x<2048; x++) for (var y=0; y<2048; y++)
            {
              	var xx = x;
              	var yy = y;

              	if (showscaled && cycle==0)
  	            {
  	            	  xx = Math.floor((x-1024-align_x[tile])*scaling+1024);
  	        		    yy = Math.floor((y-1024-align_y[tile])*scaling+1024);
  	            }

              	if (xx>=0 && xx<2048 && yy>=0 && yy<2048) if (current_image_data[x+y*2048] > max) max = current_image_data[xx+yy*2048];
            }

            for (var x=0; x<2048; x++) for (var y=0; y<2048; y++)
            {
                var index = x+2048*y;

                var val = 0;

                var xx = x;
                var yy = y;

                if (showscaled && cycle==0)
                {
                	xx = Math.floor((x-1024-align_x[tile])*scaling+1024);
            		  yy = Math.floor((y-1024-align_y[tile])*scaling+1024);
                }

                if (xx >= 0 && yy >= 0 && xx < 2048 && yy < 2048) val = current_image_data[xx+2048*yy]/max*255 *brightness;
                if (val > 255) val = 255;

                ImageArray[4*index+0] = val;
                ImageArray[4*index+1] = val;
                ImageArray[4*index+2] = val;
                ImageArray[4*index+3] = 255;
            }

            if (showspots && cycle==0) //pheno
            {
              for (var i=0; i<p_cell_num; i++) if (p_cell_tile[i] == tile)
              {
              	var map = p_cell_map[i];
                var r = (340850327*map)%255;
                var g = (934895*map)%255;
                var b = (3538497218*map)%255;

                if (map != -1)
                	for (var xxx=-5; xxx<=5; xxx++) //if (xxx<=-3 || xxx>=3) //5x5 px black
                  		for (var yyy=-5; yyy<=5; yyy++)
                {
                  var xx = Math.floor(p_cell_x[i]+xxx);
                  var yy = Math.floor(p_cell_y[i]+yyy);
                  if (showscaled)
                  {
                    var xx = Math.floor((p_cell_x[i]-1024)/scaling+1024+align_x[tile]+xxx);
                    var yy = Math.floor((p_cell_y[i]-1024)/scaling+1024+align_y[tile]+yyy);
                  }

                  if (xx>=0 && xx < 2048 && yy>=0 && yy <2048)
                  {
                    var index = xx+2048*yy;
                    ImageArray[4*index+0] = r;
                    ImageArray[4*index+1] = g;
                    ImageArray[4*index+2] = b;
                    ImageArray[4*index+3] = 255;
                  }
                }
              }
            }

            if (showspots && cycle==1) //insitu
            {
              for (var i=0; i<i_cell_num; i++) if (i_cell_tile[i] == tile)
              {
                var r = (340850327*i)%255;
                var g = (934895*i)%255;
                var b = (3538497218*i)%255;

                for (var xxx=-5; xxx<=5; xxx++) //if (xxx<=-3 || xxx>=3) //5x5 px black
                  for (var yyy=-5; yyy<=5; yyy++)
                {
                  var xx = Math.floor(i_cell_x[i]+xxx);
                  var yy = Math.floor(i_cell_y[i]+yyy);

                  if (xx>=0 && xx < 2048 && yy>=0 && yy <2048)
                  {
                    var index = xx+2048*yy;
                    ImageArray[4*index+0] = r;
                    ImageArray[4*index+1] = g;
                    ImageArray[4*index+2] = b;
                    ImageArray[4*index+3] = 255;
                  }
                }
              }
            }

            ImageContext.putImageData(ImageData, 0, 0);

            if (callback) callback();
          };
          reader.readAsArrayBuffer(files[image_id]);
        }






        function LoadAlignmentFile()
        {
          var reader = new FileReader();
          reader.onload = function(evt)
          {
            var table = reader.result.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
            var start_tile_p = document.getElementById("start_tile_p").value*1;
            var start_tile_is = document.getElementById("start_tile_is").value*1;

            align_tile = new Int16Array(num_tiles1);
            for (var i=0; i<num_tiles1; i++) align_tile[i] = -1;
            align_x = new Int16Array(num_tiles1);
            align_y = new Int16Array(num_tiles1);
            align_q = new Int16Array(num_tiles1);

            for (var i=0; i<table.length; i++)
            {
              var line = table[i].split("\t");

              var ii = line[0]*1 - start_tile_p;
              if (ii >= 0)
              {
                align_tile[ii] = line[1]*1 - start_tile_is;
                align_x[ii] = line[2]*1;
                align_y[ii] = line[3]*1;
                align_q[ii] = line[4]*1;
              }
            }
          };
          reader.readAsText(document.getElementById("AlignmentFile").files[0]);
        }



        function SaveFile(data, filename)
        {
            var bb = new Blob([data], {type: 'text/plain'});
            var a = document.createElement('a');
            a.download = filename;
            a.href = window.URL.createObjectURL(bb);
            a.textContent = 'Klick here to save';
            a.dataset.downloadurl = ['text/plain', a.download, a.href].join(':');
            document.getElementById("save").appendChild(a);
            a.click();
        }

        function mouseDown(evt)
        {
            mouseDragging = true;

            var svg = document.getElementById("maincanvas");
            var box = svg.getBoundingClientRect();

            mouseX = evt.clientX-box.left;
            mouseY = evt.clientY-box.top;

            var mindist, best=-1;
            var tile_p = document.getElementById("tile").value*1;
            var tile_is = align_tile[document.getElementById("tile").value*1];
            for (var i=0; i<spot_num; i++) if (spot_tile[i] == tile_is)
            {
              var xx = Math.floor((mouseX/800*2048-1024)/3+align_x[tile_p]+1024);
              var yy = Math.floor((mouseY/800*2048-1024)/3+align_y[tile_p]+1024);

              var dx = spot_x[i] - xx;
              var dy = spot_y[i] - yy;
              var d = dx*dx + dy*dy;
              if (best==-1 || d<mindist)
              {
                best = i;
                mindist = d;
              }
            }
            if (mindist < 100)
            {
              document.getElementById("current_seq").value = spot_seq[best];
              //alert(highlighted_seq)
              UpdateCanvas();
            }
            //alert(mouseX+" "+mouseY)

            return false;
        }
        document.getElementById("maincanvas").addEventListener("mousedown", mouseDown, false);






        var current_cropping_cycle = 0, current_cropping_tile = 0;
        var total_aligned_cells, total_assigned_cells;
        function StartCropping()
        {
          out = "";
          current_cropping_cycle = 0;
          current_cropping_tile = 0;
          total_aligned_cells = 0;
          total_assigned_cells = 0;
          LoadImage(current_cropping_cycle, current_cropping_tile, 0, 0, CroppingCallback);
        }
        function CroppingCallback()
        {
          document.getElementById("status").innerHTML = " tile-"+current_cropping_tile;

          if (current_cropping_cycle == 0) // pheno
          {
            DetectCells();

            //copy to global array:
            if (align_tile[current_cropping_tile] != -1) //exclude tiles with no aligned in-situ tile
              for (var i=0; i<cell_num; i++)
                  if (cell_x[i]>edge && cell_x[i]<2048-edge && cell_y[i]>edge && cell_y[i]<2048-edge)
            {
              p_cell_tile[p_cell_num] = current_cropping_tile;
              p_cell_x[p_cell_num] = cell_x[i];
              p_cell_y[p_cell_num] = cell_y[i];
              p_cell_n[p_cell_num] = cell_n[i];
              p_cell_num++;
            }

            current_cropping_tile++;
            if (current_cropping_tile < num_tiles1) LoadImage(current_cropping_cycle, current_cropping_tile, 0, 0, CroppingCallback);
            else
            {
              current_cropping_cycle = 1;
              current_cropping_tile = 0;
              LoadImage(current_cropping_cycle, current_cropping_tile, 0, 0, CroppingCallback);
            }
            return;
          }
          if (current_cropping_cycle == 1) // insitu
          {
            DetectCells();

            //copy to global array:
            for (var i=0; i<cell_num; i++)
                if (cell_x[i]>edge && cell_x[i]<2048-edge && cell_y[i]>edge && cell_y[i]<2048-edge)
            {
              i_cell_tile[i_cell_num] = current_cropping_tile;
              i_cell_x[i_cell_num] = cell_x[i];
              i_cell_y[i_cell_num] = cell_y[i];
              i_cell_n[i_cell_num] = cell_n[i];
              i_cell_id[i_cell_num] = i+1; //original cellpose id
              i_cell_num++;
            }

            current_cropping_tile++;
            if (current_cropping_tile < num_tiles2) LoadImage(current_cropping_cycle, current_cropping_tile, 0, 0, CroppingCallback);
            else
            {
              current_cropping_cycle = 2;
              current_cropping_tile = 0;
              LoadImage(current_cropping_cycle, current_cropping_tile, 0, 0, CroppingCallback);
            }
            return;
          }
          if (current_cropping_cycle == 2) // pheno mem
          {
            //retrieve the cell-id for every recognized cell:
            for (var i=0; i<p_cell_num; i++) if (p_cell_tile[i] == current_cropping_tile)
            {
              var x = p_cell_x[i];
              var y = p_cell_y[i];
              p_cell_id[i] = current_image_data[x+2048*y];
            }

            current_cropping_tile++;
            if (current_cropping_tile < num_tiles3) LoadImage(current_cropping_cycle, current_cropping_tile, 0, 0, CroppingCallback);
            else
            {
              AssignCells();
              SaveAssigments();
            }
          }
        }
        



        var cell_num = 0, cell_x, cell_y, cell_n;
        function DetectCells()
        {
        	//find number of cells:
        	cell_num = 0;
        	for (var x=0; x<2048; x++) for (var y=0; y<2048; y++) if (current_image_data[x+2048*y] > cell_num) cell_num = current_image_data[x+2048*y];

        	//reserve memory:
        	cell_x = new Float32Array(cell_num);
        	cell_y = new Float32Array(cell_num);
        	cell_n = new Float32Array(cell_num);
        	cell_map = new Float32Array(cell_num);

        	//determine center of each cell:
        	for (var x=0; x<2048; x++) for (var y=0; y<2048; y++) if (current_image_data[x+2048*y] > 0)
        	{
        		cell = current_image_data[x+2048*y]-1;
        		cell_x[cell] += x;
        		cell_y[cell] += y;
        		cell_n[cell]++;
        	}
        	for (var cell=0; cell<cell_num; cell++)
        	{
        		cell_x[cell] /= cell_n[cell];
        		cell_y[cell] /= cell_n[cell];
        	}
        }

        var max_cell_num = 1000000*10;
        var p_cell_num = 0;
        var p_cell_tile = new Uint32Array(max_cell_num);
        var p_cell_x = new Uint32Array(max_cell_num);
        var p_cell_y = new Uint32Array(max_cell_num);
        var p_cell_n = new Uint32Array(max_cell_num);
        var p_cell_map = new Int32Array(max_cell_num);
        var p_cell_id = new Int32Array(max_cell_num);

        var i_cell_num = 0;
        var i_cell_tile = new Uint32Array(max_cell_num);
        var i_cell_x = new Uint32Array(max_cell_num);
        var i_cell_y = new Uint32Array(max_cell_num);
        var i_cell_n = new Uint32Array(max_cell_num);
        var i_cell_id = new Uint32Array(max_cell_num);


        var edge = 50; //less than overlap
        function AssignCells()
        {
        	var scaling = document.getElementById("scaling").value*1;
          var maxdist = document.getElementById("maxdist").value*1;
          var px_per_step = document.getElementById("px_per_step").value*1;
          var py_per_step = document.getElementById("py_per_step").value*1;
          var use_overlapping_tiles = document.getElementById("use_overlapping_tiles").checked;
          var area_gating = document.getElementById("area_gating").checked;

        	for (var i=0; i<p_cell_num; i++)
        	{
        		var x = p_cell_x[i];
        		var y = p_cell_y[i];

            //transform pheno pos to mathed in-situ pos:
            var i_t = align_tile[p_cell_tile[i]];
            var i_x = (p_cell_x[i]-1024)/scaling+1024+align_x[p_cell_tile[i]];
            var i_y = (p_cell_y[i]-1024)/scaling+1024+align_y[p_cell_tile[i]];
            //if (i_t == -1) alert("tile was not successfully aligned");

            //find best in-situ tile:
            if (use_overlapping_tiles && i_t != -1)
            {
              var best_i_t = -1, best_fromcenter, best_i_x, best_i_y;
              for (var t=0; t<num_tiles2; t++)
              {
                var d_xstep = StagePositions1X[t]-StagePositions1X[i_t];
                var d_ystep = StagePositions1Y[t]-StagePositions1Y[i_t];

                if (d_xstep >= -1 && d_xstep <= 1 && d_ystep >= -1 && d_ystep <= 1)
                {
                  var i_xx = i_x - d_xstep*px_per_step - d_ystep*py_per_step;
                  var i_yy = i_y - d_xstep*py_per_step + d_ystep*px_per_step;
                  //to do: check correct orientation of y steps

                  var fromcenter = (i_xx-1024)**2 + (i_yy-1024)**2;

                  if (best_i_t == -1 || fromcenter < best_fromcenter)
                  {
                    best_i_t = t;
                    best_fromcenter = fromcenter;
                    best_i_x = i_xx;
                    best_i_y = i_yy;
                  }
                }
              }
              i_t = best_i_t;
              i_x = best_i_x;
              i_y = best_i_y;
            }

        		var min_dist = 10000000, min_cell = -1;
        		if (x>edge && x<2048-edge && y>edge && y<2048-edge) //ignore edge cells
        			for (var ii=0; ii<i_cell_num; ii++)
                if (i_cell_tile[ii] == i_t)
        		{
        			var dx = i_x-i_cell_x[ii];
        			var dy = i_y-i_cell_y[ii];
        			var d = dx*dx + dy*dy;

        			var rel_area = p_cell_n[i] / i_cell_n[ii] /scaling/scaling; // /7.55

        			if (d<maxdist*maxdist)
        				if ((!area_gating) || rel_area > 0.5 && rel_area < 2)
        					if (min_cell == -1 || d < min_dist)
        			{
        				min_dist = d;
        				min_cell = ii;
        			}
        		}
        		p_cell_map[i] = min_cell;
            //if (p_cell_tile[i] == 1) alert(x+" "+y+" "+i_t+" "+i_x+" "+i_y)
        	}

        	//remove pheno cells mapping to the same in-situ cell:
        	var i_cell_match_count = new Uint32Array(i_cell_num);
        	for (var i=0; i<p_cell_num; i++) i_cell_match_count[p_cell_map[i]]++;
        	for (var i=0; i<p_cell_num; i++) if (i_cell_match_count[p_cell_map[i]] > 1) p_cell_map[i] = -1;

          //count success rate:
          var total_mapped = 0;
          for (var i=0; i<p_cell_num; i++) if (p_cell_map[i] != -1) total_mapped++;
          alert(/*p_cell_num+" phenotype cells, "+i_cell_num+" in-situ cells, "+total_mapped+ */ "Mapped: "+Math.round(total_mapped/p_cell_num*100*10)/10+"%");
        }

        function SaveAssigments()
        {
          var out = "in-situ_tile\tcell\tx\ty\tarea\tpheno_tile\tcell\tx\ty\tarea";
          for (var i=0; i<p_cell_num; i++)
          {
            var ii = p_cell_map[i];
            if (ii > -1) out += "\n"+i_cell_tile[ii]+"\t"+i_cell_id[ii]+"\t"+i_cell_x[ii]+"\t"+i_cell_y[ii]+"\t"+i_cell_n[ii]+"\t"+p_cell_tile[i]+"\t"+p_cell_id[i]+"\t"+p_cell_x[i]+"\t"+p_cell_y[i]+"\t"+p_cell_n[i];
          }
          SaveFile(out, "CellAssignments.txt");

          //mapping rate per tile:
          var tile_n = new Uint32Array(num_tiles1);
          var tile_mapped = new Uint32Array(num_tiles1);
          for (var i=0; i<p_cell_num; i++)
          {
            tile_n[p_cell_tile[i]]++;
            if (p_cell_map[i] != -1) tile_mapped[p_cell_tile[i]]++;
          }
          var out = "cells\tmapped";
          for (var i=0; i<num_tiles1; i++) out += "\n"+tile_n[i]+"\t"+tile_mapped[i];
          SaveFile(out, "TileAssignmentStats.txt");
        }

    </script>
